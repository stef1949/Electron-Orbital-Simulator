<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electron Orbital Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
   <!-- Three.js r160 with WebGPU support using ES modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #181818;
            color: #f7f7f7;
        }
        #app-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
            padding: 1rem;
        }
        #canvas-container {
            flex-grow: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #orbital-panel {
            position: absolute;
            top: 50%;
            right: 1rem;
            transform: translateY(-50%);
            padding: 0.5rem;
            background-color: rgba(24, 24, 36, 0.5);
            -webkit-backdrop-filter: blur(2px);
            backdrop-filter: blur(2px);
            border-radius: 0.75rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.14);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 80vh;
            overflow: auto;
            z-index: 12;
        }
        #settings-panel {
            position: absolute;
            bottom: 5rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1rem;
            background-color: rgba(30, 30, 46, 0.5);
            -webkit-backdrop-filter: blur(2px);
            backdrop-filter: blur(2px);
            border-radius: 0.75rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.14);
            display: flex;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
            z-index: 10;
        }
        .orbital-button {
            padding: 0.5rem 1rem;
            background-color: #333333;
            color: #fff;
            border-radius: 0.5rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            border: none;
        }
        .orbital-button:hover {
            transform: translateY(-2px);
            background-color: #a9a9a9;
        }
        .orbital-button:active {
            transform: translateY(0);
        }
        .orbital-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #555555;
        }
        .orbital-button:disabled:hover {
            transform: none;
            background-color: #555555;
        }
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .slider-container label {
            font-size: 0.875rem;
        }
        #fps-counter {
            position: absolute;
            top: 1rem;
            left: 1rem;
            padding: 0.5rem 1rem;
            background-color: rgba(30, 30, 46, 0.5);
            -webkit-backdrop-filter: blur(2px);
            backdrop-filter: blur(2px);
            border-radius: 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.75rem;
            font-size: 0.875rem;
            font-weight: bold;
            color: #a0aec0;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <h1 class="text-3xl sm:text-4xl font-extrabold tracking-tight mb-4 text-center">Electron Orbital Simulator</h1>
        <p class="text-sm sm:text-base text-gray-400 mb-6 text-center">Click and drag to rotate, use the scroll wheel to zoom.</p>
        <div id="canvas-container">
            <canvas id="orbital-canvas"></canvas>
            <div id="orbital-panel">
                <button class="orbital-button" data-orbital="1s">1s</button>
                <button class="orbital-button" data-orbital="2s">2s</button>
                <button class="orbital-button" data-orbital="3s">3s</button>
                <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,0.06);margin:6px 0;">
                <button class="orbital-button" data-orbital="2p_x">2p‚Çì</button>
                <button class="orbital-button" data-orbital="2p_y">2p·µß</button>
                <button class="orbital-button" data-orbital="2p_z">2pùìè</button>
                <button class="orbital-button" data-orbital="3p_x">3p‚Çì</button>
                <button class="orbital-button" data-orbital="3p_y">3p·µß</button>
                <button class="orbital-button" data-orbital="3p_z">3pùìè</button>
                <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,0.06);margin:6px 0;">
                <button class="orbital-button" data-orbital="3d_z2">3d‚ÇÇ¬≤</button>
                <button class="orbital-button" data-orbital="3d_x2-y2">3d‚Çì¬≤-·µß¬≤</button>
                <button class="orbital-button" data-orbital="3d_xy">3d‚Çì·µß</button>
                <button class="orbital-button" data-orbital="3d_xz">3d‚Çì‚ÇÇ</button>
                <button class="orbital-button" data-orbital="3d_yz">3d·µß‚ÇÇ</button>
                <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,0.06);margin:6px 0;">
                <button class="orbital-button" data-orbital="4s">4s</button>
                <button class="orbital-button" data-orbital="4p_x">4p‚Çì</button>
                <button class="orbital-button" data-orbital="4p_y">4p·µß</button>
                <button class="orbital-button" data-orbital="4p_z">4pùìè</button>
                <button class="orbital-button" data-orbital="4d_z2">4d‚ÇÇ¬≤</button>
                <button class="orbital-button" data-orbital="4d_x2-y2">4d‚Çì¬≤-·µß¬≤</button>
                <button class="orbital-button" data-orbital="4d_xy">4d‚Çì·µß</button>
                <button class="orbital-button" data-orbital="4d_xz">4d‚Çì‚ÇÇ</button>
                <button class="orbital-button" data-orbital="4d_yz">4d·µß‚ÇÇ</button>
            </div>

            <div id="settings-panel">
                <div class="slider-container">
                    <label for="density-slider">Density: <span id="density-value">50000</span> points</label>
                    <input type="range" id="density-slider" min="10000" max="150000" value="50000" step="10000">
                </div>
                <button id="adaptive-toggle" class="orbital-button">Adaptive Off</button>
                <button id="mode-toggle" class="orbital-button">Mode: Instanced</button>
                <button id="impostor-toggle" class="orbital-button">Impostor: Off</button>
                <button id="cull-toggle" class="orbital-button">Cull: Off</button>
                <button id="pause-toggle" class="orbital-button">Pause</button>
                <button id="clear-button" class="orbital-button">Clear</button>
                <button id="screenshot-button" class="orbital-button">Save PNG</button>
            </div>
            <div id="fps-counter"> FPS:0 </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

        // Global variables for debugging and console access
        window.THREE = THREE;
        window.scene = null;
        window.renderer = null;
        window.camera = null;

        async function initializeRenderer() {
            const canvas = document.getElementById('orbital-canvas');
            let renderer = null;
            let rendererType = 'unknown';

            // Try WebGPU first
            if (navigator.gpu) {
                try {
                    console.log('Attempting WebGPU initialization...');
                    renderer = new WebGPURenderer({ 
                        canvas: canvas,
                        alpha: true,
                        antialias: true
                    });
                    await renderer.init();
                    rendererType = 'WebGPU';
                    console.log('‚úÖ WebGPU renderer initialized successfully');
                } catch (error) {
                    console.warn('‚ùå WebGPU initialization failed:', error);
                    renderer = null;
                }
            } else {
                console.log('WebGPU not supported in this browser');
            }

            // Fallback to WebGL2
            if (!renderer) {
                try {
                    console.log('Falling back to WebGL2...');
                    const context = canvas.getContext('webgl2');
                    if (context) {
                        renderer = new THREE.WebGLRenderer({
                            canvas: canvas,
                            context: context,
                            alpha: true,
                            preserveDrawingBuffer: true,
                            antialias: true
                        });
                        rendererType = 'WebGL2';
                        console.log('‚úÖ WebGL2 renderer initialized successfully');
                    } else {
                        throw new Error('WebGL2 context not available');
                    }
                } catch (error) {
                    console.warn('‚ùå WebGL2 initialization failed:', error);
                }
            }

            // Final fallback to WebGL1
            if (!renderer) {
                try {
                    console.log('Final fallback to WebGL1...');
                    renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        alpha: true,
                        preserveDrawingBuffer: true,
                        antialias: true
                    });
                    rendererType = 'WebGL1';
                    console.log('‚úÖ WebGL1 renderer initialized successfully');
                } catch (error) {
                    console.error('‚ùå All renderer initialization attempts failed:', error);
                    throw new Error('No compatible renderer found');
                }
            }

            // Configure renderer
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Add renderer info to DOM
            const rendererInfo = document.createElement('div');
            rendererInfo.id = 'renderer-info';
            rendererInfo.style.cssText = `
                position: absolute;
                top: 3rem;
                left: 1rem;
                padding: 0.5rem 1rem;
                background-color: rgba(30, 30, 46, 0.8);
                backdrop-filter: blur(2px);
                border-radius: 0.75rem;
                font-size: 0.75rem;
                font-weight: bold;
                color: #a0aec0;
                z-index: 10;
            `;
            rendererInfo.textContent = `Renderer: ${rendererType}`;
            document.body.appendChild(rendererInfo);

            return { renderer, rendererType };
        }

        async function main() {
            try {
                // Initialize renderer
                const { renderer, rendererType } = await initializeRenderer();
                window.renderer = renderer;

                // --- Scene Setup ---
                const scene = new THREE.Scene();
                window.scene = scene;
                
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                window.camera = camera;

                // Set camera position and controls
                camera.position.z = 20;
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.enableZoom = true;

                // --- Lighting ---
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 1, 1);
                scene.add(directionalLight);

                // --- Orbital Visualization ---
                let currentOrbital = null;
                let currentOrbitalData = { n: 2, l: 1, m: -1 }; // Track the current orbital
                let debounceTimer = null; // debounce handle
                let paused = false; // controls per-frame resampling
                let adaptiveEnabled = false; // adaptive sampling toggle
                let adaptiveFrame = 0; // frame counter for adaptive updates
                let cachedMaxPsi2 = null; // reused across frames in adaptive mode
                let emaMaxPsi2 = null; // exponential moving average for maxPsi2
                const ADAPTIVE_MAX_RECALC_INTERVAL = 15; // frames
                const ADAPTIVE_TARGET_ACCEPT = 0.28; // target acceptance ratio
                const ADAPTIVE_BASE_ATTEMPTS_FACTOR = 6; // attempts per instance baseline
                const SUBSET_RESAMPLE_FRACTION = 0.05; // fraction of instances updated per adaptive frame
                const EMA_ALPHA = 0.25; // smoothing factor for maxPsi2
                let renderMode = 'instanced'; // 'instanced', 'points', 'gpu'
                // renderMode can also be 'gpu' for GPU-based sampling + point-cloud shader (WebGL2/WebGPU)
                let gpuBackend = rendererType; // Track which GPU backend is being used
                let occlusionEnabled = false; // toggles depth-based occlusion culling
                let impostorEnabled = false; // toggles impostor rendering for instanced mode (billboard quads instead of spheres)
                // Points mode reusable buffers
                let pointsCache = { geometry: null, material: null, capacity: 0 };
                const maxRadius = 30;
                const colorPositive = new THREE.Color(0x2e64e1); // A vibrant blue
                const colorNegative = new THREE.Color(0xff6666); // A vibrant red
                const ACCEPTANCE_SCALE = 10; // Acceptance probability scale factor
                const dummyObject3D = new THREE.Object3D(); // For instanced transforms

                // --- GPU sampling resources ---
                let gpuSampleTarget = null; // render target where samples are written (RGBA32F)
                let gpuSampleMesh = null; // points mesh that reads from the render target
                let gpuQuadScene = null; // scene used to render sampling quad
                let gpuRadialLUT = null; // DataTexture (1D) for radial lookup
                let gpuLUTSize = 0;
                const radialLUTCache = {}; // cache DataTextures per (n,l)

                // Estimate maximum |psi|^2 via random sampling for rejection sampling normalization
                function estimateMaxPsi2(n, l, m, samples = 1000) {
                    let maxPsi2 = 0;
                    for (let i = 0; i < samples; i++) {
                        const r = Math.random() * maxRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                        const psi2 = psi * psi;
                        if (psi2 > maxPsi2) maxPsi2 = psi2;
                    }
                    // Prevent division by zero
                    return maxPsi2 > 0 ? maxPsi2 : 1e-6;
                }

                // Calculates the wave function value (which can be positive or negative)
                // Note: This is a simplified, real-valued version for visualization.
                function getWaveFunctionValue(n, l, m, r, theta, phi) {
                    let radial_part = 0;
                    let angular_part = 0;

                    // Radial part R(r) - hydrogenic-like using associated Laguerre polynomials (unnormalized)
                    // Uses x = 2r/n and L^{alpha}_p where p = n-l-1, alpha = 2l+1
                    if (n <= l) {
                        radial_part = 0;
                    } else {
                        const x = 2 * r / n;
                        const p = n - l - 1;
                    const alpha = 2 * l + 1;
                    let L = 1;
                    // Associated Laguerre polynomials for p = 0..3 (covers n <= 4)
                    if (p === 0) {
                        L = 1;
                    } else if (p === 1) {
                        // L^{alpha}_1(x) = -x + alpha + 1
                        L = -x + (alpha + 1);
                    } else if (p === 2) {
                        // L^{alpha}_2(x) = 1/2 (x^2 - 2(alpha+2)x + (alpha+1)(alpha+2))
                        L = 0.5 * (x * x - 2 * (alpha + 2) * x + (alpha + 1) * (alpha + 2));
                    } else if (p === 3) {
                        // L^{alpha}_3(x) = 1/6 (-x^3 + 3(alpha+3)x^2 - 3(alpha+2)(alpha+3)x + (alpha + 1)(alpha + 2)(alpha + 3))
                        L = (1 / 6) * (-x * x * x + 3 * (alpha + 3) * x * x - 3 * (alpha + 2) * (alpha + 3) * x + (alpha + 1) * (alpha + 2) * (alpha + 3));
                    } else {
                        // For larger p fallback to a simple exponential times polynomial approximation
                        L = 1;
                    }
                    radial_part = Math.pow(x, l) * L * Math.exp(-x / 2);
                }

                // Angular part Y(theta, phi) - Real-valued Spherical Harmonics
                if (l === 0) { // s-orbital
                    angular_part = 1;
                } else if (l === 1) { // p-orbitals
                    if (m === 0) { // p_z
                        angular_part = Math.cos(theta);
                    } else if (m === 1) { // p_x
                        angular_part = Math.sin(theta) * Math.cos(phi);
                    } else if (m === -1) { // p_y
                        angular_part = Math.sin(theta) * Math.sin(phi);
                    }
                } else if (l === 2) { // d-orbitals
                    if (m === 0) { // d_z2
                        angular_part = (3 * Math.cos(theta) * Math.cos(theta) - 1);
                    } else if (m === 1) { // d_xz
                        angular_part = Math.sin(theta) * Math.cos(theta) * Math.cos(phi);
                    } else if (m === -1) { // d_yz
                        angular_part = Math.sin(theta) * Math.cos(theta) * Math.sin(phi);
                    } else if (m === 2) { // d_x2-y2
                        angular_part = Math.sin(theta) * Math.sin(theta) * Math.cos(2 * phi);
                    } else if (m === -2) { // d_xy
                        angular_part = Math.sin(theta) * Math.sin(theta) * Math.sin(2 * phi);
                    }
                }
                
                return radial_part * angular_part;
            }

            // Precompute radial LUT (1D) for R_nl(r) to avoid expensive per-sample exp/polynomial
            function createRadialLUT(n, l, size = 1024) {
                const arr = new Float32Array(size * 4); // RGBA but we only fill R channel
                for (let i = 0; i < size; i++) {
                    const t = i / (size - 1);
                    const r = t * maxRadius;
                    // compute radial part similarly to getWaveFunctionValue but only radial
                    let radial_part = 0;
                    if (n <= l) {
                        radial_part = 0;
                    } else {
                        const x = 2 * r / n;
                        const p = n - l - 1;
                        const alpha = 2 * l + 1;
                        let L = 1;
                        if (p === 0) {
                            L = 1;
                        } else if (p === 1) {
                            L = -x + (alpha + 1);
                        } else if (p === 2) {
                            L = 0.5 * (x * x - 2 * (alpha + 2) * x + (alpha + 1) * (alpha + 2));
                        } else if (p === 3) {
                            L = (1 / 6) * (-x * x * x + 3 * (alpha + 3) * x * x - 3 * (alpha + 2) * (alpha + 3) * x + (alpha + 1) * (alpha + 2) * (alpha + 3));
                        } else {
                            L = 1;
                        }
                        radial_part = Math.pow(x, l) * L * Math.exp(-x / 2);
                    }
                    arr[i * 4 + 0] = radial_part;
                    arr[i * 4 + 1] = 0;
                    arr[i * 4 + 2] = 0;
                    arr[i * 4 + 3] = 1;
                }
                const tex = new THREE.DataTexture(arr, size, 1, THREE.RGBAFormat, THREE.FloatType);
                tex.needsUpdate = true;
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.wrapS = THREE.ClampToEdgeWrapping;
                tex.wrapT = THREE.ClampToEdgeWrapping;
                return tex;
            }

                // Create or update a GPU render target sized to hold numPoints samples (RGBA32F)
                // Supports both WebGL and WebGPU backends
                function createGPUSampleTarget(numPoints) {
                    const size = Math.ceil(Math.sqrt(numPoints));
                    const width = size;
                    const height = Math.ceil(numPoints / width);
                    
                    // Dispose previous
                    if (gpuSampleTarget) {
                        gpuSampleTarget.dispose();
                        gpuSampleTarget = null;
                    }
                    
                    // WebGPU backend
                    if (gpuBackend === 'WebGPU') {
                        try {
                            console.log('Creating WebGPU render target...');
                            const rt = new THREE.RenderTarget(width, height, {
                                wrapS: THREE.ClampToEdgeWrapping,
                                wrapT: THREE.ClampToEdgeWrapping,
                                minFilter: THREE.NearestFilter,
                                magFilter: THREE.NearestFilter,
                                type: THREE.FloatType,
                                format: THREE.RGBAFormat,
                                samples: 0, // No antialiasing for sampling
                                generateMipmaps: false
                            });
                            
                            rt._texWidth = width;
                            rt._texHeight = height;
                            gpuSampleTarget = rt;
                            console.log(`‚úÖ WebGPU render target created: ${width}x${height}`);
                            return rt;
                        } catch (error) {
                            console.error('‚ùå WebGPU render target creation failed:', error);
                            return null;
                        }
                    }
                    
                    // WebGL2 backend (original implementation)
                    else if (gpuBackend === 'WebGL2') {
                        // Check WebGL capabilities before creating render target
                        const gl = renderer.getContext();
                        if (!renderer.capabilities.isWebGL2) {
                            console.error('GPU mode requires WebGL2');
                            return null;
                        }
                        
                        const floatExtension = renderer.extensions.get('EXT_color_buffer_float') || 
                                             renderer.extensions.get('WEBGL_color_buffer_float');
                        if (!floatExtension) {
                            console.error('GPU mode requires floating point render target support');
                            return null;
                        }
                        
                        const rt = new THREE.WebGLRenderTarget(width, height, {
                            wrapS: THREE.ClampToEdgeWrapping,
                            wrapT: THREE.ClampToEdgeWrapping,
                            minFilter: THREE.NearestFilter,
                            magFilter: THREE.NearestFilter,
                            type: THREE.FloatType,
                            format: THREE.RGBAFormat,
                            depthBuffer: false,
                            stencilBuffer: false
                        });
                        
                        // Validate render target creation
                        const prevTarget = renderer.getRenderTarget();
                        renderer.setRenderTarget(rt);
                        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                        renderer.setRenderTarget(prevTarget);
                        
                        if (status !== gl.FRAMEBUFFER_COMPLETE) {
                            console.error('GPU render target creation failed:', status);
                            rt.dispose();
                            return null;
                        }
                        
                        rt._texWidth = width;
                        rt._texHeight = height;
                        gpuSampleTarget = rt;
                        console.log(`‚úÖ WebGL2 render target created: ${width}x${height}`);
                        return rt;
                    }
                    
                    // WebGL1 fallback - disable GPU mode
                    else {
                        console.warn('GPU sampling requires WebGL2 or WebGPU, falling back to Points mode');
                        renderMode = 'points';
                        updateModeButtonText();
                        return null;
                    }
                }

            // Render a fullscreen quad into the sample target. Fragment shader generates
            // random samples (r,theta,phi), computes position and psi, and writes (x,y,z,psi)
            // Update the GPU sampling fragment shader to fix potential issues:
            // - Ensure rejection loop always produces a sample (fallback to uniform sampling if needed)
            // - Improve random function for better distribution
            // - Add debug output for shader compilation
                // Create WebGPU/WebGL compatible shader material for orbital sampling
                function createGPUSamplingMaterial(n, l, m, lutTexture, lutSize, maxPsi2, numPoints, resolution, seed) {
                    // Fragment shader compatible with both WebGL and WebGPU
                    const fragmentShader = `
                    uniform float uN, uL, uM;
                    uniform sampler2D uRadialLUT;
                    uniform float uLUTSize, uMaxPsi2, uNumPoints;
                    uniform vec2 uResolution;
                    uniform float uSeed;

                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                    }

                    // Better random function with improved distribution
                    float random2(vec2 st, float seed) {
                        return fract(sin(dot(st.xy + seed, vec2(12.9898, 78.233))) * 43758.5453123);
                    }

                    vec3 sphericalToCartesian(float r, float theta, float phi) {
                        return vec3(r * sin(theta) * cos(phi), r * sin(theta) * sin(phi), r * cos(theta));
                    }

                    float getRadial(float r, float n, float l) {
                        float x = 2.0 * r / n;
                        // Proper scaling based on actual LUT range
                        vec2 texCoord = vec2(clamp(x / 20.0, 0.0, 1.0), 0.0);
                        return texture(uRadialLUT, texCoord).r;
                    }

                    float getAngular(float theta, float phi, float l, float m) {
                        if (l == 0.0) return 1.0;
                        else if (l == 1.0) {
                            if (m == 0.0) return cos(theta);
                            else if (m == 1.0) return sin(theta) * cos(phi);
                            else return sin(theta) * sin(phi);
                        } else if (l == 2.0) {
                            float ct = cos(theta), st = sin(theta);
                            if (m == 0.0) return 1.5 * ct * ct - 0.5;
                            else if (m == 1.0) return -1.732 * st * ct * cos(phi);
                            else if (m == -1.0) return 1.732 * st * ct * sin(phi);
                            else if (m == 2.0) return 0.866 * st * st * cos(2.0 * phi);
                            else return 0.866 * st * st * sin(2.0 * phi);
                        }
                        return 0.0;
                    }

                    void main() {
                        vec2 uv = gl_FragCoord.xy / uResolution;
                        float idx = uv.x + uv.y * uResolution.x;
                        if (idx >= uNumPoints) discard;

                        vec2 baseSeed = uv + vec2(uSeed);
                        float psi = 0.0;
                        vec3 pos = vec3(0.0);
                        bool found = false;

                        // Rejection sampling loop with fallback
                        for (int attempt = 0; attempt < 100; attempt++) {
                            float attemptSeed = float(attempt);
                            float r = random2(baseSeed, attemptSeed) * 30.0;
                            float theta = acos(2.0 * random2(baseSeed, attemptSeed + 1.0) - 1.0);
                            float phi = random2(baseSeed, attemptSeed + 2.0) * 6.283185;

                            float radial = getRadial(r, uN, uL);
                            float angular = getAngular(theta, phi, uL, uM);
                            psi = radial * angular;
                            float psi2 = psi * psi;

                            if (random2(baseSeed, attemptSeed + 3.0) < psi2 / uMaxPsi2) {
                                pos = sphericalToCartesian(r, theta, phi);
                                found = true;
                                break;
                            }
                        }

                        // Fallback: uniform sampling if rejection fails
                        if (!found) {
                            float r = random2(baseSeed, 100.0) * 30.0;
                            float theta = acos(2.0 * random2(baseSeed, 101.0) - 1.0);
                            float phi = random2(baseSeed, 102.0) * 6.283185;
                            pos = sphericalToCartesian(r, theta, phi);
                            psi = getRadial(r, uN, uL) * getAngular(theta, phi, uL, uM);
                        }

                        gl_FragColor = vec4(pos, psi);
                    }
                    `;

                    const uniforms = {
                        uN: { value: n },
                        uL: { value: l },
                        uM: { value: m },
                        uRadialLUT: { value: lutTexture },
                        uLUTSize: { value: lutSize },
                        uMaxPsi2: { value: maxPsi2 },
                        uNumPoints: { value: numPoints },
                        uResolution: { value: resolution },
                        uSeed: { value: seed }
                    };

                    // Create shader material - works for both WebGL and WebGPU
                    return new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: `
                            void main() {
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: fragmentShader,
                        side: THREE.DoubleSide
                    });
                }

                // Update renderGPUSamples to use the new material creation function
                function renderGPUSamples(n, l, m, numPoints) {
                    // Ensure LUT exists for current n,l (cache per n,l)
                    const lutKey = `${n}_${l}`;
                    if (!radialLUTCache[lutKey]) radialLUTCache[lutKey] = createRadialLUT(n, l, 1024);
                    gpuRadialLUT = radialLUTCache[lutKey];
                    gpuLUTSize = 1024;

                    const rt = createGPUSampleTarget(numPoints);
                    if (!rt) {
                        console.error('Failed to create GPU sample target, falling back to points mode');
                        renderMode = 'points';
                        updateModeButtonText();
                        return null;
                    }
                    const width = rt._texWidth, height = rt._texHeight;

                    // Build quad scene if not present
                    if (!gpuQuadScene) {
                        gpuQuadScene = new THREE.Scene();
                    } else {
                        // dispose previous quad mesh material if any
                        if (gpuQuadScene.children.length) {
                            const old = gpuQuadScene.children[0];
                            old.material.dispose();
                            gpuQuadScene.remove(old);
                        }
                    }

                    // Use PlaneGeometry instead of deprecated PlaneBufferGeometry
                    const quadGeom = new THREE.PlaneGeometry(2, 2);
                    
                    // Create the material using our new function
                    const quadMat = createGPUSamplingMaterial(
                        n, l, m,
                        radialLUTCache[lutKey],
                        gpuLUTSize,
                        estimateMaxPsi2(n, l, m),
                        numPoints,
                        new THREE.Vector2(width, height),
                        Math.random()
                    );

                    const quad = new THREE.Mesh(quadGeom, quadMat);
                    gpuQuadScene.add(quad);

                    // render quad into target
                    const prevRenderTarget = renderer.getRenderTarget();
                    renderer.setRenderTarget(rt);
                    renderer.clear();
                    const orthoCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
                    renderer.render(gpuQuadScene, orthoCamera);
                    renderer.setRenderTarget(prevRenderTarget);

                    // Check for compilation errors (WebGL only)
                    if (gpuBackend !== 'WebGPU' && quadMat.program) {
                        const gl = renderer.getContext();
                        const program = quadMat.program.program;
                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                            console.error('GPU Shader link error:', gl.getProgramInfoLog(program));
                        }
                        const vertShader = gl.getShaderInfoLog(quadMat.program.vertexShader);
                        const fragShader = gl.getShaderInfoLog(quadMat.program.fragmentShader);
                        if (vertShader) console.error('GPU Vertex shader compile error:', vertShader);
                        if (fragShader) console.error('GPU Fragment shader compile error:', fragShader);
                    }

                    console.log(`‚úÖ GPU orbital sampling completed using ${gpuBackend}`);
                    return rt;
                }

            // Create a Points mesh whose vertex shader samples the gpuSampleTarget to get position + psi
            function createGPUPointsMesh(sampleTarget, numPoints) {
                // build a simple buffer geometry with an index attribute (float id)
                const geom = new THREE.BufferGeometry();
                const count = numPoints;
                const positions = new Float32Array(count * 3);
                const indices = new Float32Array(count);
                for (let i = 0; i < count; i++) {
                    positions[i*3+0] = 0;
                    positions[i*3+1] = 0;
                    positions[i*3+2] = 0;
                    indices[i] = i;
                }
                geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geom.setAttribute('aIndex', new THREE.BufferAttribute(indices, 1));

                const width = sampleTarget._texWidth, height = sampleTarget._texHeight;
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        uSamples: { value: sampleTarget.texture },
                        uTexSize: { value: new THREE.Vector2(width, height) },
                        uPointSize: { value: 0.3 },
                        uColorPos: { value: colorPositive },
                        uColorNeg: { value: colorNegative }
                    },
                    vertexShader: `
                        attribute float aIndex;
                        uniform sampler2D uSamples;
                        uniform vec2 uTexSize;
                        uniform float uPointSize;
                        varying float vPsi;
                        varying vec3 vColor;
                        void main() {
                            float id = aIndex;
                            float w = uTexSize.x;
                            float h = uTexSize.y;
                            float ix = mod(id, w);
                            float iy = floor(id / w);
                            vec2 uv = vec2((ix + 0.5) / w, (iy + 0.5) / h);
                            vec4 s = texture2D(uSamples, uv);
                            vec3 pos = s.xyz;
                            float psi = s.w;
                            vPsi = psi;
                            if (psi >= 0.0) vColor = vec3(0.18, 0.39, 0.88); else vColor = vec3(1.0, 0.4, 0.4);
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = uPointSize * (1.0 + clamp(abs(psi) * 8.0, 0.0, 6.0));
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        precision highp float;
                        varying float vPsi;
                        varying vec3 vColor;
                        void main() {
                            float a = clamp(abs(vPsi) * 2.0, 0.0, 1.0);
                            gl_FragColor = vec4(vColor * a, a);
                        }
                    `,
                    transparent: true,
                    depthWrite: !occlusionEnabled,
                    depthTest: occlusionEnabled,
                    blending: THREE.AdditiveBlending
                });

                const points = new THREE.Points(geom, mat);
                points.userData = points.userData || {};
                points.userData.isOrbital = true;
                return points;
            }

            // Regenerate using true probability density |psi|^2 and GPU instancing (InstancedMesh)
            function regenerateOrbitalGeometry() {
                const { n, l, m } = currentOrbitalData;
                const numPoints = parseInt(densitySlider.value);

                // Remove any previous orbital objects from the scene (safe cleanup)
                scene.children.slice().forEach(child => {
                    if (child.userData && child.userData.isOrbital) {
                        // dispose geometries/materials if present
                        if (child.type === 'Group') {
                            child.children.forEach(ch => {
                                ch.geometry?.dispose?.();
                                ch.material?.dispose?.();
                            });
                        } else {
                            child.geometry?.dispose?.();
                            child.material?.dispose?.();
                        }
                        scene.remove(child);
                    }
                });
                currentOrbital = null;

                // Estimate max |psi|^2 for normalization (rejection sampling)
                const maxPsi2 = estimateMaxPsi2(n, l, m);

                // If GPU mode requested but renderer doesn't support float render targets, fallback
                if (renderMode === 'gpu') {
                    const supports = renderer.capabilities.isWebGL2 && (renderer.extensions.get('EXT_color_buffer_float') || renderer.extensions.get('WEBGL_color_buffer_float'));
                    if (!supports) {
                        console.warn('Floating point render targets not supported; falling back to points mode');
                        renderMode = 'points';
                    } else {
                        console.info('GPU sampling enabled (float render targets available)');
                    }
                }

                // Geometry & materials (reuse by caching on function property)
                if (!regenerateOrbitalGeometry._sphereGeo) {
                    regenerateOrbitalGeometry._sphereGeo = new THREE.SphereGeometry(0.12, 6, 6);
                    regenerateOrbitalGeometry._quadGeo = new THREE.PlaneBufferGeometry(0.24, 0.24); // quad for impostors
                    const commonMatOpts = {
                        transparent: true,
                        opacity: 0.5,
                        depthWrite: !occlusionEnabled,
                        depthTest: occlusionEnabled,
                        blending: THREE.AdditiveBlending
                    };
                    regenerateOrbitalGeometry._matPos = new THREE.MeshBasicMaterial({ color: colorPositive, ...commonMatOpts });
                    regenerateOrbitalGeometry._matNeg = new THREE.MeshBasicMaterial({ color: colorNegative, ...commonMatOpts });
                    
                    // Billboard materials for impostors
                    const billboardVertShader = `
                        attribute vec3 instancePosition;
                        attribute float instanceScale;
                        varying vec3 vColor;
                        uniform vec3 color;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;
                        
                        void main() {
                            vec3 pos = instancePosition;
                            vec3 toCamera = normalize(cameraPosition - pos);
                            vec3 up = vec3(0.0, 1.0, 0.0);
                            vec3 right = normalize(cross(toCamera, up));
                            up = cross(right, toCamera);
                            
                            vec3 vertex = position * instanceScale;
                            vertex = right * vertex.x + up * vertex.y + toCamera * vertex.z;
                            pos += vertex;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                            vColor = color;
                        }
                    `;
                    const billboardFragShader = `
                        varying vec3 vColor;
                        void main() {
                            gl_FragColor = vec4(vColor, 1.0);
                        }
                    `;
                    
                    regenerateOrbitalGeometry._matPosBillboard = new THREE.ShaderMaterial({
                        uniforms: {
                            color: { value: colorPositive },
                            cameraPosition: { value: camera.position }
                        },
                        vertexShader: billboardVertShader,
                        fragmentShader: billboardFragShader,
                        transparent: true,
                        depthWrite: !occlusionEnabled,
                        depthTest: occlusionEnabled,
                        blending: THREE.AdditiveBlending
                    });
                    
                    regenerateOrbitalGeometry._matNegBillboard = new THREE.ShaderMaterial({
                        uniforms: {
                            color: { value: colorNegative },
                            cameraPosition: { value: camera.position }
                        },
                        vertexShader: billboardVertShader,
                        fragmentShader: billboardFragShader,
                        transparent: true,
                        depthWrite: !occlusionEnabled,
                        depthTest: occlusionEnabled,
                        blending: THREE.AdditiveBlending
                    });
                }
                const sphereGeo = regenerateOrbitalGeometry._sphereGeo;
                const quadGeo = regenerateOrbitalGeometry._quadGeo;
                const matPos = regenerateOrbitalGeometry._matPos;
                const matNeg = regenerateOrbitalGeometry._matNeg;
                const matPosBillboard = regenerateOrbitalGeometry._matPosBillboard;
                const matNegBillboard = regenerateOrbitalGeometry._matNegBillboard;

                // Choose rendering path
                if (renderMode === 'points') {
                    // Remove old (already cleaned above)
                    // Ensure capacity
                    if (!pointsCache.geometry || pointsCache.capacity < numPoints) {
                        pointsCache.geometry?.dispose?.();
                        pointsCache.material?.dispose?.();
                        const geom = new THREE.BufferGeometry();
                        const posArr = new Float32Array(numPoints * 3);
                        const colArr = new Float32Array(numPoints * 3);
                        geom.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
                        geom.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
                        pointsCache.geometry = geom;
                        pointsCache.material = new THREE.PointsMaterial({ size: 0.08, vertexColors: true, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending, depthWrite: !occlusionEnabled, depthTest: occlusionEnabled });
                        pointsCache.capacity = numPoints;
                    }
                    const geom = pointsCache.geometry;
                    const posArr = geom.getAttribute('position').array;
                    const colArr = geom.getAttribute('color').array;
                    // Fill via rejection sampling using estimateMaxPsi2
                    const maxPsi2 = estimateMaxPsi2(n, l, m, Math.min(1200, Math.max(200, numPoints)));
                    let written = 0, attempts = 0, MAX_ATTEMPTS = numPoints * 20;
                    while (written < numPoints && attempts < MAX_ATTEMPTS) {
                        attempts++;
                        const r = Math.random() * maxRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        const cosPhi = Math.cos(phi);
                        const x = r * sinTheta * cosPhi;
                        const y = r * sinTheta * Math.sin(phi);
                        const z = r * cosTheta;
                        const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                        const psi2 = psi * psi;
                        if (Math.random() <= psi2 / maxPsi2) {
                            const i = written * 3;
                            posArr[i] = x; posArr[i+1] = y; posArr[i+2] = z;
                            const c = psi >= 0 ? colorPositive : colorNegative;
                            colArr[i] = c.r; colArr[i+1] = c.g; colArr[i+2] = c.b;
                            written++;
                        }
                    }
                    geom.getAttribute('position').needsUpdate = true;
                    geom.getAttribute('color').needsUpdate = true;
                    const points = new THREE.Points(geom, pointsCache.material);
                    points.userData = points.userData || {};
                    points.userData.isOrbital = true;
                    currentOrbital = points;
                    scene.add(points);
                    // store capacities
                    currentOrbital._posCapacity = Math.ceil(numPoints/2);
                    currentOrbital._negCapacity = Math.floor(numPoints/2);
                    currentOrbital._lastConfig = { n, l, m, numPoints };
                    return;
                }

                // GPU mode: render samples into a float texture then draw points that read from it
                if (renderMode === 'gpu') {
                    // Clean old (already cleaned above)
                    const rt = renderGPUSamples(n, l, m, numPoints);
                    if (!rt) {
                        // GPU mode failed, renderGPUSamples should have set renderMode to 'points'
                        // Re-call this function to regenerate with points mode
                        regenerateOrbitalGeometry(n, l, m, numPoints);
                        return;
                    }
                    // create GPU points mesh
                    gpuSampleTarget = rt;
                    if (gpuSampleMesh) {
                        gpuSampleMesh.geometry.dispose();
                        gpuSampleMesh.material.dispose();
                        scene.remove(gpuSampleMesh);
                        gpuSampleMesh = null;
                    }
                    gpuSampleMesh = createGPUPointsMesh(rt, numPoints);
                    gpuSampleMesh.userData = gpuSampleMesh.userData || {};
                    gpuSampleMesh.userData.isOrbital = true;
                    currentOrbital = gpuSampleMesh;
                    scene.add(gpuSampleMesh);
                    currentOrbital._lastConfig = { n, l, m, numPoints };
                    return;
                }

                // First pass: sample and store transforms separately by sign
                const posTransforms = [];
                const negTransforms = [];
                const MAX_ATTEMPTS = numPoints * 5;
                let attempts = 0;
                while ((posTransforms.length + negTransforms.length) < numPoints && attempts < MAX_ATTEMPTS) {
                    attempts++;
                    const r = Math.random() * maxRadius;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = Math.random() * 2 * Math.PI;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    const cosPhi = Math.cos(phi);
                    const sinPhi = Math.sin(phi);
                    const x = r * sinTheta * cosPhi;
                    const y = r * sinTheta * sinPhi;
                    const z = r * cosTheta;
                    const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                    const psi2 = psi * psi;
                    if (Math.random() <= psi2 / maxPsi2) {
                        const scale = 0.55 + 0.45 * Math.min(1, Math.sqrt(psi2 / maxPsi2));
                        if (psi >= 0) posTransforms.push({ x, y, z, scale }); else negTransforms.push({ x, y, z, scale });
                    }
                }

                // Choose geometry and materials based on impostor mode (only for instanced mode)
                const useImpostor = impostorEnabled && renderMode === 'instanced';
                const useGeo = useImpostor ? quadGeo : sphereGeo;
                const useMatPos = useImpostor ? matPosBillboard : matPos;
                const useMatNeg = useImpostor ? matNegBillboard : matNeg;

                const posMesh = new THREE.InstancedMesh(useGeo, useMatPos, posTransforms.length || 1);
                const negMesh = new THREE.InstancedMesh(useGeo, useMatNeg, negTransforms.length || 1);
                // mark meshes so global cleanup will remove them when changing modes
                posMesh.userData = posMesh.userData || {};
                negMesh.userData = negMesh.userData || {};
                posMesh.userData.isOrbital = true;
                negMesh.userData.isOrbital = true;

                // For impostors, add instance attributes for position and scale
                if (useImpostor) {
                    const posPositions = new Float32Array(posTransforms.length * 3);
                    const posScales = new Float32Array(posTransforms.length);
                    posTransforms.forEach((t, i) => {
                        posPositions[i*3] = t.x;
                        posPositions[i*3+1] = t.y;
                        posPositions[i*3+2] = t.z;
                        posScales[i] = t.scale;
                    });
                    posMesh.geometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(posPositions, 3));
                    posMesh.geometry.setAttribute('instanceScale', new THREE.InstancedBufferAttribute(posScales, 1));
                    
                    const negPositions = new Float32Array(negTransforms.length * 3);
                    const negScales = new Float32Array(negTransforms.length);
                    negTransforms.forEach((t, i) => {
                        negPositions[i*3] = t.x;
                        negPositions[i*3+1] = t.y;
                        negPositions[i*3+2] = t.z;
                        negScales[i] = t.scale;
                    });
                    negMesh.geometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(negPositions, 3));
                    negMesh.geometry.setAttribute('instanceScale', new THREE.InstancedBufferAttribute(negScales, 1));
                } else {
                    // For spheres, use the standard instance matrix approach
                    posTransforms.forEach((t, i) => {
                        dummyObject3D.position.set(t.x, t.y, t.z);
                        dummyObject3D.scale.setScalar(t.scale);
                        dummyObject3D.updateMatrix();
                        posMesh.setMatrixAt(i, dummyObject3D.matrix);
                    });
                    negTransforms.forEach((t, i) => {
                        dummyObject3D.position.set(t.x, t.y, t.z);
                        dummyObject3D.scale.setScalar(t.scale);
                        dummyObject3D.updateMatrix();
                        negMesh.setMatrixAt(i, dummyObject3D.matrix);
                    });
                }
                posMesh.instanceMatrix.needsUpdate = true;
                negMesh.instanceMatrix.needsUpdate = true;

                const group = new THREE.Group();
                group.add(posMesh);
                group.add(negMesh);
                // mark group for cleanup as well
                group.userData = group.userData || {};
                group.userData.isOrbital = true;
                currentOrbital = group;
                scene.add(group);
                // Store capacity metadata for in-place updates
                currentOrbital._posCapacity = posMesh.count;
                currentOrbital._negCapacity = negMesh.count;
                currentOrbital._lastConfig = { n, l, m, numPoints };
            }

            function scheduleRegeneration(delay = 60) {
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(regenerateOrbitalGeometry, delay);
            }

            // In-place resampling without reallocating meshes (called each frame when not paused)
            function resampleOrbitalInPlace() {
                // GPU mode: re-render samples into the target and update points texture
                if (renderMode === 'gpu') {
                    const { n: gpuN, l: gpuL, m: gpuM } = currentOrbitalData;
                    const gpuDesiredPoints = parseInt(densitySlider.value);
                    // If config changed, regenerate geometry
                    const gpuSameConfig = currentOrbital && currentOrbital._lastConfig && currentOrbital._lastConfig.n === gpuN && currentOrbital._lastConfig.l === gpuL && currentOrbital._lastConfig.m === gpuM && currentOrbital._lastConfig.numPoints === gpuDesiredPoints;
                    const rt = renderGPUSamples(gpuN, gpuL, gpuM, gpuDesiredPoints);
                    if (!rt) {
                        // GPU mode failed, regenerate with the new mode
                        regenerateOrbitalGeometry(gpuN, gpuL, gpuM, gpuDesiredPoints);
                        return;
                    }
                    gpuSampleTarget = rt;

                    // Ensure old orbital objects are removed before adding/updating GPU mesh
                    scene.children.slice().forEach(child => {
                        if (child.userData && child.userData.isOrbital) {
                            if (child !== gpuSampleMesh) {
                                child.geometry?.dispose?.();
                                child.material?.dispose?.();
                                scene.remove(child);
                            }
                        }
                    });

                    if (gpuSampleMesh) {
                        gpuSampleMesh.material.uniforms.uSamples.value = rt.texture;
                        currentOrbital._lastConfig = { n: gpuN, l: gpuL, m: gpuM, numPoints: gpuDesiredPoints };
                    } else {
                        // create mesh if missing
                        gpuSampleMesh = createGPUPointsMesh(rt, gpuDesiredPoints);
                        gpuSampleMesh.userData = gpuSampleMesh.userData || {};
                        gpuSampleMesh.userData.isOrbital = true;
                        scene.add(gpuSampleMesh);
                        currentOrbital = gpuSampleMesh;
                        currentOrbital._lastConfig = { n: gpuN, l: gpuL, m: gpuM, numPoints: gpuDesiredPoints };
                    }
                    return;
                }

                // Points mode: resample the buffer geometry positions and colors
                if (renderMode === 'points') {
                    if (!currentOrbital || currentOrbital.type !== 'Points') return;
                    const { n: pointsN, l: pointsL, m: pointsM } = currentOrbitalData;
                    const pointsDesiredPoints = parseInt(densitySlider.value);
                    const pointsSameConfig = currentOrbital._lastConfig && currentOrbital._lastConfig.n === pointsN && currentOrbital._lastConfig.l === pointsL && currentOrbital._lastConfig.m === pointsM && currentOrbital._lastConfig.numPoints === pointsDesiredPoints;
                    if (!pointsSameConfig) {
                        regenerateOrbitalGeometry();
                        return;
                    }
                    
                    const geom = currentOrbital.geometry;
                    const posArr = geom.getAttribute('position').array;
                    const colArr = geom.getAttribute('color').array;
                    const numPoints = posArr.length / 3;
                    
                    if (!adaptiveEnabled) {
                        // Full refresh for points mode
                        const maxPsi2 = estimateMaxPsi2(pointsN, pointsL, pointsM, Math.min(1200, Math.max(200, numPoints)));
                        let written = 0, attempts = 0, MAX_ATTEMPTS = numPoints * 20;
                        while (written < numPoints && attempts < MAX_ATTEMPTS) {
                            attempts++;
                            const r = Math.random() * maxRadius;
                            const theta = Math.acos(2 * Math.random() - 1);
                            const phi = Math.random() * 2 * Math.PI;
                            const sinTheta = Math.sin(theta);
                            const cosTheta = Math.cos(theta);
                            const cosPhi = Math.cos(phi);
                            const x = r * sinTheta * cosPhi;
                            const y = r * sinTheta * Math.sin(phi);
                            const z = r * cosTheta;
                            const psi = getWaveFunctionValue(pointsN, pointsL, pointsM, r, theta, phi);
                            const psi2 = psi * psi;
                            if (Math.random() <= psi2 / maxPsi2) {
                                const i = written * 3;
                                posArr[i] = x; posArr[i+1] = y; posArr[i+2] = z;
                                const c = psi >= 0 ? colorPositive : colorNegative;
                                colArr[i] = c.r; colArr[i+1] = c.g; colArr[i+2] = c.b;
                                written++;
                            }
                        }
                        // Fill remaining with zeros (invisible points)
                        for (let i = written; i < numPoints; i++) {
                            const idx = i * 3;
                            posArr[idx] = 0; posArr[idx+1] = 0; posArr[idx+2] = 0;
                            colArr[idx] = 0; colArr[idx+1] = 0; colArr[idx+2] = 0;
                        }
                    } else {
                        // Adaptive mode for points: update random subset
                        if (!cachedMaxPsi2 || adaptiveFrame % ADAPTIVE_MAX_RECALC_INTERVAL === 0) {
                            const fresh = estimateMaxPsi2(pointsN, pointsL, pointsM, 600);
                            if (emaMaxPsi2 == null) emaMaxPsi2 = fresh; else emaMaxPsi2 = EMA_ALPHA * fresh + (1 - EMA_ALPHA) * emaMaxPsi2;
                            cachedMaxPsi2 = emaMaxPsi2;
                        }
                        const maxPsi2 = cachedMaxPsi2 || 1e-6;
                        const updates = Math.max(1, Math.floor(numPoints * SUBSET_RESAMPLE_FRACTION));
                        
                        let attempts = 0, accepted = 0;
                        for (let i = 0; i < updates; i++) {
                            const idx = (Math.random() * numPoints) | 0;
                            const ATTEMPT_LIMIT = 40;
                            for (let a = 0; a < ATTEMPT_LIMIT; a++) {
                                attempts++;
                                const r = Math.random() * maxRadius;
                                const theta = Math.acos(2 * Math.random() - 1);
                                const phi = Math.random() * 2 * Math.PI;
                                const sinTheta = Math.sin(theta);
                                const cosTheta = Math.cos(theta);
                                const cosPhi = Math.cos(phi);
                                const sinPhi = Math.sin(phi);
                                const x = r * sinTheta * cosPhi;
                                const y = r * sinTheta * sinPhi;
                                const z = r * cosTheta;
                                const psi = getWaveFunctionValue(pointsN, pointsL, pointsM, r, theta, phi);
                                const psi2 = psi * psi;
                                if (Math.random() <= psi2 / maxPsi2) {
                                    const posIdx = idx * 3;
                                    posArr[posIdx] = x; posArr[posIdx+1] = y; posArr[posIdx+2] = z;
                                    const c = psi >= 0 ? colorPositive : colorNegative;
                                    colArr[posIdx] = c.r; colArr[posIdx+1] = c.g; colArr[posIdx+2] = c.b;
                                    accepted++;
                                    break;
                                }
                            }
                        }
                        currentOrbital._prevAcceptRatio = accepted > 0 ? (accepted / attempts) : currentOrbital._prevAcceptRatio;
                        adaptiveFrame++;
                    }
                    
                    geom.getAttribute('position').needsUpdate = true;
                    geom.getAttribute('color').needsUpdate = true;
                    return;
                }

                if (!currentOrbital || currentOrbital.type !== 'Group') return;
                const { n, l, m } = currentOrbitalData;
                const desiredPoints = parseInt(densitySlider.value);
                const sameConfig = currentOrbital._lastConfig && currentOrbital._lastConfig.n === n && currentOrbital._lastConfig.l === l && currentOrbital._lastConfig.m === m && currentOrbital._lastConfig.numPoints === desiredPoints;
                if (!sameConfig) {
                    regenerateOrbitalGeometry();
                    return;
                }
                const posMesh = currentOrbital.children[0];
                const negMesh = currentOrbital.children[1];
                const posCapacity = currentOrbital._posCapacity;
                const negCapacity = currentOrbital._negCapacity;
                const totalCapacity = posCapacity + negCapacity;
                if (!adaptiveEnabled) {
                    // ORIGINAL full refresh path (non-adaptive)
                    let posFilled = 0, negFilled = 0, attempts = 0, accepted = 0;
                    const maxPsi2 = estimateMaxPsi2(n, l, m, 1500);
                    const maxAttempts = totalCapacity * 15;
                    while ((posFilled < posCapacity || negFilled < negCapacity) && attempts < maxAttempts) {
                        attempts++;
                        const r = Math.random() * maxRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        const cosPhi = Math.cos(phi);
                        const x = r * sinTheta * cosPhi;
                        const y = r * sinTheta * Math.sin(phi);
                        const z = r * cosTheta;
                        const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                        const psi2 = psi * psi;
                        if (Math.random() <= psi2 / maxPsi2) {
                            const scale = 0.55 + 0.45 * Math.min(1, Math.sqrt(psi2 / maxPsi2));
                            dummyObject3D.position.set(x, y, z);
                            dummyObject3D.scale.setScalar(scale);
                            dummyObject3D.updateMatrix();
                            if (psi >= 0 && posFilled < posCapacity) {
                                posMesh.setMatrixAt(posFilled++, dummyObject3D.matrix);
                            } else if (psi < 0 && negFilled < negCapacity) {
                                negMesh.setMatrixAt(negFilled++, dummyObject3D.matrix);
                            }
                            accepted++;
                        }
                    }
                    // Hide remainder
                    if (posFilled < posCapacity) {
                        dummyObject3D.scale.setScalar(0); dummyObject3D.updateMatrix();
                        for (let i = posFilled; i < posCapacity; i++) posMesh.setMatrixAt(i, dummyObject3D.matrix);
                    }
                    if (negFilled < negCapacity) {
                        dummyObject3D.scale.setScalar(0); dummyObject3D.updateMatrix();
                        for (let i = negFilled; i < negCapacity; i++) negMesh.setMatrixAt(i, dummyObject3D.matrix);
                    }
                    posMesh.instanceMatrix.needsUpdate = true;
                    negMesh.instanceMatrix.needsUpdate = true;
                    return;
                }

                // ADAPTIVE MODE: incremental subset update
                if (!cachedMaxPsi2 || adaptiveFrame % ADAPTIVE_MAX_RECALC_INTERVAL === 0) {
                    const fresh = estimateMaxPsi2(n, l, m, 600);
                    if (emaMaxPsi2 == null) emaMaxPsi2 = fresh; else emaMaxPsi2 = EMA_ALPHA * fresh + (1 - EMA_ALPHA) * emaMaxPsi2;
                    cachedMaxPsi2 = emaMaxPsi2;
                }
                const maxPsi2 = cachedMaxPsi2 || 1e-6;
                const posUpdates = Math.max(1, Math.floor(posCapacity * SUBSET_RESAMPLE_FRACTION));
                const negUpdates = Math.max(1, Math.floor(negCapacity * SUBSET_RESAMPLE_FRACTION));

                let attempts = 0, accepted = 0;
                function updateOne(targetMesh, isPositive, index) {
                    // attempt loop per slot
                    const ATTEMPT_LIMIT = 40;
                    for (let a = 0; a < ATTEMPT_LIMIT; a++) {
                        attempts++;
                        const r = Math.random() * maxRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        const cosPhi = Math.cos(phi);
                        const sinPhi = Math.sin(phi);
                        const x = r * sinTheta * cosPhi;
                        const y = r * sinTheta * sinPhi;
                        const z = r * cosTheta;
                        const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                        if ((isPositive && psi < 0) || (!isPositive && psi >= 0)) continue; // sign mismatch
                        const psi2 = psi * psi;
                        if (Math.random() <= psi2 / maxPsi2) {
                            const scale = 0.55 + 0.45 * Math.min(1, Math.sqrt(psi2 / maxPsi2));
                            dummyObject3D.position.set(x, y, z);
                            dummyObject3D.scale.setScalar(scale);
                            dummyObject3D.updateMatrix();
                            targetMesh.setMatrixAt(index, dummyObject3D.matrix);
                            accepted++;
                            break;
                        }
                    }
                }
                for (let i = 0; i < posUpdates; i++) updateOne(posMesh, true, (Math.random() * posCapacity) | 0);
                for (let i = 0; i < negUpdates; i++) updateOne(negMesh, false, (Math.random() * negCapacity) | 0);
                posMesh.instanceMatrix.needsUpdate = true;
                negMesh.instanceMatrix.needsUpdate = true;
                currentOrbital._prevAcceptRatio = accepted > 0 ? (accepted / attempts) : currentOrbital._prevAcceptRatio;
                adaptiveFrame++;
            }

             // --- FPS Counter Logic ---
            let prevTime = performance.now();
            let frames = 0;
            const fpsCounter = document.getElementById('fps-counter');

            // --- Event Listeners and Initial State ---
            const buttons = document.querySelectorAll('#orbital-panel .orbital-button');
            const densitySlider = document.getElementById('density-slider');
            const densityValueLabel = document.getElementById('density-value');
            const pauseButton = document.getElementById('pause-toggle');
            const adaptiveButton = document.getElementById('adaptive-toggle');
            const modeButton = document.getElementById('mode-toggle');
            const impostorButton = document.getElementById('impostor-toggle');
            const cullButton = document.getElementById('cull-toggle');
            const clearButton = document.getElementById('clear-button');
            const screenshotButton = document.getElementById('screenshot-button'); // new

            // Function to update mode button text (can be called when mode changes due to fallback)
            function updateModeButtonText() {
                modeButton.textContent = renderMode === 'instanced' ? 'Mode: Instanced' : (renderMode === 'points' ? 'Mode: Points' : 'Mode: GPU');
            }

            // Initialize button states
            pauseButton.textContent = paused ? 'Resume' : 'Pause';
            adaptiveButton.textContent = adaptiveEnabled ? 'Adaptive On' : 'Adaptive Off';
            updateModeButtonText();
            impostorButton.textContent = impostorEnabled ? 'Impostor: On' : 'Impostor: Off';
            cullButton.textContent = occlusionEnabled ? 'Cull: On' : 'Cull: Off';

            buttons.forEach(button => {
                button.addEventListener('click', (event) => {
                    buttons.forEach(btn => btn.classList.remove('active'));
                    event.target.classList.add('active');
                    const orbitalType = event.target.dataset.orbital;
                    switch (orbitalType) {
                        case '1s': currentOrbitalData = { n: 1, l: 0, m: 0 }; break;
                        case '2s': currentOrbitalData = { n: 2, l: 0, m: 0 }; break;
                        case '3s': currentOrbitalData = { n: 3, l: 0, m: 0 }; break;
                        case '2p_x': currentOrbitalData = { n: 2, l: 1, m: 1 }; break;
                        case '2p_y': currentOrbitalData = { n: 2, l: 1, m: -1 }; break;
                        case '2p_z': currentOrbitalData = { n: 2, l: 1, m: 0 }; break;
                        case '3p_x': currentOrbitalData = { n: 3, l: 1, m: 1 }; break;
                        case '3p_y': currentOrbitalData = { n: 3, l: 1, m: -1 }; break;
                        case '3p_z': currentOrbitalData = { n: 3, l: 1, m: 0 }; break;
                        case '3d_z2': currentOrbitalData = { n: 3, l: 2, m: 0 }; break;
                        case '3d_x2-y2': currentOrbitalData = { n: 3, l: 2, m: 2 }; break;
                        case '3d_xy': currentOrbitalData = { n: 3, l: 2, m: -2 }; break;
                        case '3d_xz': currentOrbitalData = { n: 3, l: 2, m: 1 }; break;
                        case '3d_yz': currentOrbitalData = { n: 3, l: 2, m: -1 }; break;
                        case '4s': currentOrbitalData = { n: 4, l: 0, m: 0 }; break;
                        case '4p_x': currentOrbitalData = { n: 4, l: 1, m: 1 }; break;
                        case '4p_y': currentOrbitalData = { n: 4, l: 1, m: -1 }; break;
                        case '4p_z': currentOrbitalData = { n: 4, l: 1, m: 0 }; break;
                        case '4d_z2': currentOrbitalData = { n: 4, l: 2, m: 0 }; break;
                        case '4d_x2-y2': currentOrbitalData = { n: 4, l: 2, m: 2 }; break;
                        case '4d_xy': currentOrbitalData = { n: 4, l: 2, m: -2 }; break;
                        case '4d_xz': currentOrbitalData = { n: 4, l: 2, m: 1 }; break;
                        case '4d_yz': currentOrbitalData = { n: 4, l: 2, m: -1 }; break;
                    }
                    scheduleRegeneration(80);
                });
            });

            densitySlider.addEventListener('input', (event) => {
                const newDensity = parseInt(event.target.value);
                densityValueLabel.textContent = newDensity.toLocaleString();
                scheduleRegeneration(120);
            });

            pauseButton.addEventListener('click', () => {
                paused = !paused;
                pauseButton.textContent = paused ? 'Resume' : 'Pause';
            });
            adaptiveButton.addEventListener('click', () => {
                adaptiveEnabled = !adaptiveEnabled;
                adaptiveButton.textContent = adaptiveEnabled ? 'Adaptive On' : 'Adaptive Off';
                // Force regeneration to reset caches
                cachedMaxPsi2 = null;
                scheduleRegeneration(10);
            });
            modeButton.addEventListener('click', () => {
                // Cycle through instanced -> points -> gpu
                if (renderMode === 'instanced') renderMode = 'points';
                else if (renderMode === 'points') renderMode = 'gpu';
                else renderMode = 'instanced';
                updateModeButtonText();
                
                // Update impostor button availability
                if (renderMode === 'instanced') {
                    impostorButton.disabled = false;
                    impostorButton.textContent = impostorEnabled ? 'Impostor: On' : 'Impostor: Off';
                } else {
                    impostorButton.disabled = true;
                    impostorButton.textContent = 'Impostor: N/A';
                }
                
                scheduleRegeneration(30);
            });

            // Cull toggle
            cullButton.addEventListener('click', () => {
                occlusionEnabled = !occlusionEnabled;
                cullButton.textContent = occlusionEnabled ? 'Cull: On' : 'Cull: Off';
                // Force regeneration so materials respect depthTest/depthWrite
                scheduleRegeneration(20);
            });

            // Impostor toggle
            impostorButton.addEventListener('click', () => {
                impostorEnabled = !impostorEnabled;
                impostorButton.textContent = impostorEnabled ? 'Impostor: On' : 'Impostor: Off';
                // Force regeneration to switch between spheres and quads
                scheduleRegeneration(20);
            });

            // Clear button
            clearButton.addEventListener('click', () => {
                clearOrbital();
            });

            // Screenshot button: render with transparent clear and download PNG
            screenshotButton.addEventListener('click', () => {
                takeScreenshot();
            });

            // takes a transparent PNG of the current view and triggers a download
            function takeScreenshot(filename = 'orbital_screenshot.png') {
                // store previous clear color & alpha
                const prevColor = renderer.getClearColor(new THREE.Color()).getHex();
                const prevAlpha = renderer.getClearAlpha();

                // render transparent background
                renderer.setClearColor(0x000000, 0);
                renderer.render(scene, camera);

                // get PNG data
                const dataURL = renderer.domElement.toDataURL('image/png');

                // restore previous clear color/alpha
                renderer.setClearColor(prevColor, prevAlpha);

                // trigger download
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
            }
            // Set initial state
            document.querySelector('[data-orbital="1s"]').classList.add('active');
            
            // Handle window resizing (debounced)
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                }, 120);
            });

            // --- Animation Loop ---
            // Render loop (geometry only regenerated on demand)
            const animate = () => {
                requestAnimationFrame(animate);
                if (!paused) {
                    resampleOrbitalInPlace();
                }
                controls.update();
                
                // Update billboard material camera positions for proper billboarding
                if (regenerateOrbitalGeometry._matPosBillboard) {
                    regenerateOrbitalGeometry._matPosBillboard.uniforms.cameraPosition.value.copy(camera.position);
                }
                if (regenerateOrbitalGeometry._matNegBillboard) {
                    regenerateOrbitalGeometry._matNegBillboard.uniforms.cameraPosition.value.copy(camera.position);
                }
                
                renderer.render(scene, camera);
                const currentTime = performance.now();
                frames++;
                if (currentTime - prevTime >= 1000) {
                    fpsCounter.textContent = `FPS: ${frames}`;
                    prevTime = currentTime;
                    frames = 0;
                }
            };

            // Initial generation
            regenerateOrbitalGeometry();
            animate();

            // Remove and dispose any current orbital objects and GPU targets
            function clearOrbital() {
                // remove orbital-marked children
                scene.children.slice().forEach(child => {
                    if (child.userData && child.userData.isOrbital) {
                        if (child.type === 'Group') {
                            child.children.forEach(ch => { ch.geometry?.dispose?.(); ch.material?.dispose?.(); });
                        } else {
                            child.geometry?.dispose?.();
                            child.material?.dispose?.();
                        }
                        scene.remove(child);
                    }
                });
                // dispose GPU resources
                if (gpuSampleMesh) {
                    gpuSampleMesh.geometry?.dispose?.();
                    gpuSampleMesh.material?.dispose?.();
                    scene.remove(gpuSampleMesh);
                    gpuSampleMesh = null;
                }
                if (gpuSampleTarget) {
                    gpuSampleTarget.dispose?.();
                    gpuSampleTarget = null;
                }
                // clear cached current orbital reference
                currentOrbital = null;
            }

            } catch (error) {
                console.error('‚ùå Application initialization failed:', error);
                // Show error message to user
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(220, 53, 69, 0.9);
                    color: white;
                    padding: 2rem;
                    border-radius: 0.5rem;
                    font-family: monospace;
                    z-index: 1000;
                    max-width: 80%;
                    text-align: center;
                `;
                errorDiv.innerHTML = `
                    <h3>‚ö†Ô∏è Application Error</h3>
                    <p>Failed to initialize the orbital simulator.</p>
                    <p><small>Error: ${error.message}</small></p>
                    <p><small>Please try a different browser or check WebGL/WebGPU support.</small></p>
                `;
                document.body.appendChild(errorDiv);
            }
        }

        // Initialize the application when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }
    </script>
</body>
</html>