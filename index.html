<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electron Orbital Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
   <!-- Three.js + OrbitControls, pinned to r128 and loaded in order -->
    <script defer src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #181818;
            color: #f7f7f7;
        }
        #app-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
            padding: 1rem;
        }
        #canvas-container {
            flex-grow: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #orbital-panel {
            position: absolute;
            top: 50%;
            right: 1rem;
            transform: translateY(-50%);
            padding: 0.5rem;
            background-color: rgba(24, 24, 36, 0.5);
            backdrop-filter: blur(2px);
            border-radius: 0.75rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.14);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 80vh;
            overflow: auto;
            z-index: 12;
        }

        #settings-panel {
            position: absolute;
            bottom: 5rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1rem;
            background-color: rgba(30, 30, 46, 0.5);
            backdrop-filter: blur(2px);
            border-radius: 0.75rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.14);
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
            z-index: 10;
        }
        .orbital-button {
            padding: 0.5rem 1rem;
            background-color: #333333;
            color: #fff;
            border-radius: 0.5rem;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            border: none;
        }
        .orbital-button:hover {
            transform: translateY(-2px);
            background-color: #a9a9a9;
        }
        .orbital-button:active {
            transform: translateY(0);
        }
        .orbital-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #555555;
        }
        .orbital-button:disabled:hover {
            transform: none;
            background-color: #555555;
        }
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .slider-container label {
            font-size: 0.875rem;
            color: #a0aec0;
        }
        #fps-counter {
            position: absolute;
            top: 1rem;
            left: 1rem;
            padding: 0.5rem 1rem;
            background-color: rgba(30, 30, 46, 0.5);
            backdrop-filter: blur(2px);
            border-radius: 0.75rem;
            font-size: 0.875rem;
            font-weight: bold;
            color: #a0aec0;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <h1 class="text-3xl sm:text-4xl font-extrabold tracking-tight mb-4 text-center">Electron Orbital Simulator</h1>
        <p class="text-sm sm:text-base text-gray-400 mb-6 text-center">Click and drag to rotate, use the scroll wheel to zoom.</p>
        <div id="canvas-container">
            <canvas id="orbital-canvas"></canvas>
            <div id="orbital-panel">
                <button class="orbital-button" data-orbital="1s">1s</button>
                <button class="orbital-button" data-orbital="2s">2s</button>
                <button class="orbital-button" data-orbital="3s">3s</button>
                <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,0.06);margin:6px 0;">
                <button class="orbital-button" data-orbital="2p_x">2p‚Çì</button>
                <button class="orbital-button" data-orbital="2p_y">2p·µß</button>
                <button class="orbital-button" data-orbital="2p_z">2pùìè</button>
                <button class="orbital-button" data-orbital="3p_x">3p‚Çì</button>
                <button class="orbital-button" data-orbital="3p_y">3p·µß</button>
                <button class="orbital-button" data-orbital="3p_z">3pùìè</button>
                <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,0.06);margin:6px 0;">
                <button class="orbital-button" data-orbital="3d_z2">3d‚ÇÇ¬≤</button>
                <button class="orbital-button" data-orbital="3d_x2-y2">3d‚Çì¬≤-·µß¬≤</button>
                <button class="orbital-button" data-orbital="3d_xy">3d‚Çì·µß</button>
                <button class="orbital-button" data-orbital="3d_xz">3d‚Çì‚ÇÇ</button>
                <button class="orbital-button" data-orbital="3d_yz">3d·µß‚ÇÇ</button>
                <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,0.06);margin:6px 0;">
                <button class="orbital-button" data-orbital="4s">4s</button>
                <button class="orbital-button" data-orbital="4p_x">4p‚Çì</button>
                <button class="orbital-button" data-orbital="4p_y">4p·µß</button>
                <button class="orbital-button" data-orbital="4p_z">4pùìè</button>
                <button class="orbital-button" data-orbital="4d_z2">4d‚ÇÇ¬≤</button>
                <button class="orbital-button" data-orbital="4d_x2-y2">4d‚Çì¬≤-·µß¬≤</button>
                <button class="orbital-button" data-orbital="4d_xy">4d‚Çì·µß</button>
                <button class="orbital-button" data-orbital="4d_xz">4d‚Çì‚ÇÇ</button>
                <button class="orbital-button" data-orbital="4d_yz">4d·µß‚ÇÇ</button>
            </div>

            <div id="settings-panel">
                <div class="slider-container">
                    <label for="density-slider">Density: <span id="density-value">50000</span> points</label>
                    <input type="range" id="density-slider" min="10000" max="150000" value="50000" step="10000">
                </div>
                <button id="adaptive-toggle" class="orbital-button">Adaptive Off</button>
                <button id="mode-toggle" class="orbital-button">Mode: Instanced</button>
                <button id="impostor-toggle" class="orbital-button">Impostor: Off</button>
                <button id="cull-toggle" class="orbital-button">Cull: Off</button>
                <button id="pause-toggle" class="orbital-button">Pause</button>
                <button id="clear-button" class="orbital-button">Clear</button>
            </div>
            <div id="fps-counter"> FPS:0 </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Request a WebGL2 rendering context
            const canvas = document.getElementById('orbital-canvas');
            const context = canvas.getContext('webgl2');

            // Initialize the renderer with the WebGL2 context
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                context: context,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Set camera position and controls
            camera.position.z = 20;
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);

            // --- Orbital Visualization ---
            let currentOrbital = null;
            let currentOrbitalData = { n: 2, l: 1, m: -1 }; // Track the current orbital
            let debounceTimer = null; // debounce handle
            let paused = false; // controls per-frame resampling
            let adaptiveEnabled = false; // adaptive sampling toggle
            let adaptiveFrame = 0; // frame counter for adaptive updates
            let cachedMaxPsi2 = null; // reused across frames in adaptive mode
            let emaMaxPsi2 = null; // exponential moving average for maxPsi2
            const ADAPTIVE_MAX_RECALC_INTERVAL = 15; // frames
            const ADAPTIVE_TARGET_ACCEPT = 0.28; // target acceptance ratio
            const ADAPTIVE_BASE_ATTEMPTS_FACTOR = 6; // attempts per instance baseline
            const SUBSET_RESAMPLE_FRACTION = 0.05; // fraction of instances updated per adaptive frame
            const EMA_ALPHA = 0.25; // smoothing factor for maxPsi2
            let renderMode = 'instanced'; // 'instanced' or 'points'
            // renderMode can also be 'gpu' for GPU-based sampling + point-cloud shader
            let occlusionEnabled = false; // toggles depth-based occlusion culling
            let impostorEnabled = false; // toggles impostor rendering for instanced mode (billboard quads instead of spheres)
            // Points mode reusable buffers
            let pointsCache = { geometry: null, material: null, capacity: 0 };
            const maxRadius = 30;
            const colorPositive = new THREE.Color(0x2e64e1); // A vibrant blue
            const colorNegative = new THREE.Color(0xff6666); // A vibrant red
            const ACCEPTANCE_SCALE = 10; // Acceptance probability scale factor
            const dummyObject3D = new THREE.Object3D(); // For instanced transforms

            // --- GPU sampling resources ---
            let gpuSampleTarget = null; // render target where samples are written (RGBA32F)
            let gpuSampleMesh = null; // points mesh that reads from the render target
            let gpuQuadScene = null; // scene used to render sampling quad
            let gpuRadialLUT = null; // DataTexture (1D) for radial lookup
            let gpuLUTSize = 0;
            const radialLUTCache = {}; // cache DataTextures per (n,l)

            // Estimate maximum |psi|^2 via random sampling for rejection sampling normalization
            function estimateMaxPsi2(n, l, m, samples = 1000) {
                let maxPsi2 = 0;
                for (let i = 0; i < samples; i++) {
                    const r = Math.random() * maxRadius;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = Math.random() * 2 * Math.PI;
                    const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                    const psi2 = psi * psi;
                    if (psi2 > maxPsi2) maxPsi2 = psi2;
                }
                // Prevent division by zero
                return maxPsi2 > 0 ? maxPsi2 : 1e-6;
            }

            // Calculates the wave function value (which can be positive or negative)
            // Note: This is a simplified, real-valued version for visualization.
            function getWaveFunctionValue(n, l, m, r, theta, phi) {
                let radial_part = 0;
                let angular_part = 0;

                // Radial part R(r) - hydrogenic-like using associated Laguerre polynomials (unnormalized)
                // Uses x = 2r/n and L^{alpha}_p where p = n-l-1, alpha = 2l+1
                if (n <= l) {
                    radial_part = 0;
                } else {
                    const x = 2 * r / n;
                    const p = n - l - 1;
                    const alpha = 2 * l + 1;
                    let L = 1;
                    // Associated Laguerre polynomials for p = 0..3 (covers n <= 4)
                    if (p === 0) {
                        L = 1;
                    } else if (p === 1) {
                        // L^{alpha}_1(x) = -x + alpha + 1
                        L = -x + (alpha + 1);
                    } else if (p === 2) {
                        // L^{alpha}_2(x) = 1/2 (x^2 - 2(alpha+2)x + (alpha+1)(alpha+2))
                        L = 0.5 * (x * x - 2 * (alpha + 2) * x + (alpha + 1) * (alpha + 2));
                    } else if (p === 3) {
                        // L^{alpha}_3(x) = 1/6 (-x^3 + 3(alpha+3)x^2 - 3(alpha+2)(alpha+3)x + (alpha+1)(alpha+2)(alpha+3))
                        L = (1 / 6) * (-x * x * x + 3 * (alpha + 3) * x * x - 3 * (alpha + 2) * (alpha + 3) * x + (alpha + 1) * (alpha + 2) * (alpha + 3));
                    } else {
                        // For larger p fallback to a simple exponential times polynomial approximation
                        L = 1;
                    }
                    radial_part = Math.pow(x, l) * L * Math.exp(-x / 2);
                }

                // Angular part Y(theta, phi) - Real-valued Spherical Harmonics
                if (l === 0) { // s-orbital
                    angular_part = 1;
                } else if (l === 1) { // p-orbitals
                    if (m === 0) { // p_z
                        angular_part = Math.cos(theta);
                    } else if (m === 1) { // p_x
                        angular_part = Math.sin(theta) * Math.cos(phi);
                    } else if (m === -1) { // p_y
                        angular_part = Math.sin(theta) * Math.sin(phi);
                    }
                } else if (l === 2) { // d-orbitals
                    if (m === 0) { // d_z2
                        angular_part = (3 * Math.cos(theta) * Math.cos(theta) - 1);
                    } else if (m === 1) { // d_xz
                        angular_part = Math.sin(theta) * Math.cos(theta) * Math.cos(phi);
                    } else if (m === -1) { // d_yz
                        angular_part = Math.sin(theta) * Math.cos(theta) * Math.sin(phi);
                    } else if (m === 2) { // d_x2-y2
                        angular_part = Math.sin(theta) * Math.sin(theta) * Math.cos(2 * phi);
                    } else if (m === -2) { // d_xy
                        angular_part = Math.sin(theta) * Math.sin(theta) * Math.sin(2 * phi);
                    }
                }
                
                return radial_part * angular_part;
            }

            // Precompute radial LUT (1D) for R_nl(r) to avoid expensive per-sample exp/polynomial
            function createRadialLUT(n, l, size = 1024) {
                const arr = new Float32Array(size * 4); // RGBA but we only fill R channel
                for (let i = 0; i < size; i++) {
                    const t = i / (size - 1);
                    const r = t * maxRadius;
                    // compute radial part similarly to getWaveFunctionValue but only radial
                    let radial_part = 0;
                    if (n <= l) {
                        radial_part = 0;
                    } else {
                        const x = 2 * r / n;
                        const p = n - l - 1;
                        const alpha = 2 * l + 1;
                        let L = 1;
                        if (p === 0) {
                            L = 1;
                        } else if (p === 1) {
                            L = -x + (alpha + 1);
                        } else if (p === 2) {
                            L = 0.5 * (x * x - 2 * (alpha + 2) * x + (alpha + 1) * (alpha + 2));
                        } else if (p === 3) {
                            L = (1 / 6) * (-x * x * x + 3 * (alpha + 3) * x * x - 3 * (alpha + 2) * (alpha + 3) * x + (alpha + 1) * (alpha + 2) * (alpha + 3));
                        } else {
                            L = 1;
                        }
                        radial_part = Math.pow(x, l) * L * Math.exp(-x / 2);
                    }
                    arr[i * 4 + 0] = radial_part;
                    arr[i * 4 + 1] = 0;
                    arr[i * 4 + 2] = 0;
                    arr[i * 4 + 3] = 1;
                }
                const tex = new THREE.DataTexture(arr, size, 1, THREE.RGBAFormat, THREE.FloatType);
                tex.needsUpdate = true;
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.wrapS = THREE.ClampToEdgeWrapping;
                tex.wrapT = THREE.ClampToEdgeWrapping;
                return tex;
            }

            // Create or update a GPU render target sized to hold numPoints samples (RGBA32F)
            function createGPUSampleTarget(numPoints) {
                const size = Math.ceil(Math.sqrt(numPoints));
                const width = size;
                const height = Math.ceil(numPoints / width);
                // Dispose previous
                if (gpuSampleTarget) {
                    gpuSampleTarget.dispose();
                    gpuSampleTarget = null;
                }
                const rt = new THREE.WebGLRenderTarget(width, height, {
                    wrapS: THREE.ClampToEdgeWrapping,
                    wrapT: THREE.ClampToEdgeWrapping,
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    type: THREE.FloatType,
                    format: THREE.RGBAFormat,
                    depthBuffer: false,
                    stencilBuffer: false
                });
                rt._texWidth = width;
                rt._texHeight = height;
                gpuSampleTarget = rt;
                return rt;
            }

            // Render a fullscreen quad into the sample target. Fragment shader generates
            // random samples (r,theta,phi), computes position and psi, and writes (x,y,z,psi)
            // Update the GPU sampling fragment shader to fix potential issues:
            // - Ensure rejection loop always produces a sample (fallback to uniform sampling if needed)
            // - Improve random function for better distribution
            // - Add debug output for shader compilation
            const gpuSampleFragShader = `
uniform float uN, uL, uM;
uniform sampler2D uRadialLUT;
uniform float uLUTSize, uMaxPsi2, uNumPoints;
uniform vec2 uResolution;
uniform float uSeed;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

vec3 sphericalToCartesian(float r, float theta, float phi) {
    return vec3(r * sin(theta) * cos(phi), r * sin(theta) * sin(phi), r * cos(theta));
}

float getRadial(float r, float n, float l) {
    float x = 2.0 * r / n;
    vec2 texCoord = vec2((x / 10.0), 0.0);
    return texture(uRadialLUT, texCoord).r;
}

float getAngular(float theta, float phi, float l, float m) {
    if (l == 0.0) return 1.0;
    else if (l == 1.0) {
        if (m == 0.0) return cos(theta);
        else if (m == 1.0) return sin(theta) * cos(phi);
        else return sin(theta) * sin(phi);
    } else if (l == 2.0) {
        float ct = cos(theta), st = sin(theta);
        if (m == 0.0) return 1.5 * ct * ct - 0.5;
        else if (m == 1.0) return -1.732 * st * ct * cos(phi);
        else if (m == -1.0) return 1.732 * st * ct * sin(phi);
        else if (m == 2.0) return 0.866 * st * st * cos(2.0 * phi);
        else return 0.866 * st * st * sin(2.0 * phi);
    }
    return 0.0;
}

void main() {
    vec2 uv = gl_FragCoord.xy / uResolution;
    float idx = uv.x * uNumPoints;
    if (idx >= uNumPoints) discard;

    vec2 seed = uv + uSeed;
    float psi = 0.0;
    vec3 pos = vec3(0.0);
    bool found = false;

    // Rejection sampling loop with fallback
    for (int attempt = 0; attempt < 100; attempt++) {
        float r = random(seed) * 30.0;
        float theta = acos(2.0 * random(seed + 1.0) - 1.0);
        float phi = random(seed + 2.0) * 6.283185;
        seed += 3.0;

        float radial = getRadial(r, uN, uL);
        float angular = getAngular(theta, phi, uL, uM);
        psi = radial * angular;
        float psi2 = psi * psi;

        if (random(seed) < psi2 / uMaxPsi2) {
            pos = sphericalToCartesian(r, theta, phi);
            found = true;
            break;
        }
    }

    // Fallback: uniform sampling if rejection fails
    if (!found) {
        float r = random(seed) * 30.0;
        float theta = acos(2.0 * random(seed + 1.0) - 1.0);
        float phi = random(seed + 2.0) * 6.283185;
        pos = sphericalToCartesian(r, theta, phi);
        psi = getRadial(r, uN, uL) * getAngular(theta, phi, uL, uM);
    }

    gl_FragColor = vec4(pos, psi);
}
`;

            // Update renderGPUSamples to log shader compilation errors
            function renderGPUSamples(n, l, m, numPoints) {
                // Ensure LUT exists for current n,l (cache per n,l)
                const lutKey = `${n}_${l}`;
                if (!radialLUTCache[lutKey]) radialLUTCache[lutKey] = createRadialLUT(n, l, 1024);
                gpuRadialLUT = radialLUTCache[lutKey];
                gpuLUTSize = 1024;

                const rt = createGPUSampleTarget(numPoints);
                const width = rt._texWidth, height = rt._texHeight;

                // Build quad scene if not present
                if (!gpuQuadScene) {
                    gpuQuadScene = new THREE.Scene();
                } else {
                    // dispose previous quad mesh material if any
                    if (gpuQuadScene.children.length) {
                        const old = gpuQuadScene.children[0];
                        old.material.dispose();
                        gpuQuadScene.remove(old);
                    }
                }

                const quadGeom = new THREE.PlaneBufferGeometry(2, 2);
                const quadMat = new THREE.ShaderMaterial({
                    uniforms: {
                        uN: { value: n },
                        uL: { value: l },
                        uM: { value: m },
                        uRadialLUT: { value: radialLUTCache[`${n}_${l}`] },
                        uLUTSize: { value: 256 },
                        uMaxPsi2: { value: estimateMaxPsi2(n, l, m) }, // precompute max |psi|^2
                        uNumPoints: { value: numPoints },
                        uResolution: { value: new THREE.Vector2(gpuSampleTarget.width, gpuSampleTarget.height) },
                        uSeed: { value: Math.random() }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: gpuSampleFragShader // updated
                });

                // After creating quadMat, check for compilation errors
                if (quadMat.program) {
                    const gl = renderer.getContext();
                    const program = quadMat.program.program;
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        console.error('Shader link error:', gl.getProgramInfoLog(program));
                    }
                    const fragLog = gl.getShaderInfoLog(quadMat.program.fragmentShader);
                    if (fragLog) console.error('Fragment shader compile error:', fragLog);
                }

                const quad = new THREE.Mesh(quadGeom, quadMat);
                gpuQuadScene.add(quad);

                // render quad into target
                const prevRenderTarget = renderer.getRenderTarget();
                renderer.setRenderTarget(rt);
                renderer.clear();
                const orthoCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
                renderer.render(gpuQuadScene, orthoCamera);
                renderer.setRenderTarget(prevRenderTarget);

                return rt;
            }

            // Create a Points mesh whose vertex shader samples the gpuSampleTarget to get position + psi
            function createGPUPointsMesh(sampleTarget, numPoints) {
                // build a simple buffer geometry with an index attribute (float id)
                const geom = new THREE.BufferGeometry();
                const count = numPoints;
                const positions = new Float32Array(count * 3);
                const indices = new Float32Array(count);
                for (let i = 0; i < count; i++) {
                    positions[i*3+0] = 0;
                    positions[i*3+1] = 0;
                    positions[i*3+2] = 0;
                    indices[i] = i;
                }
                geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geom.setAttribute('aIndex', new THREE.BufferAttribute(indices, 1));

                const width = sampleTarget._texWidth, height = sampleTarget._texHeight;
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        uSamples: { value: sampleTarget.texture },
                        uTexSize: { value: new THREE.Vector2(width, height) },
                        uPointSize: { value: 0.3 },
                        uColorPos: { value: colorPositive },
                        uColorNeg: { value: colorNegative }
                    },
                    vertexShader: `
                        attribute float aIndex;
                        uniform sampler2D uSamples;
                        uniform vec2 uTexSize;
                        uniform float uPointSize;
                        varying float vPsi;
                        varying vec3 vColor;
                        void main() {
                            float id = aIndex;
                            float w = uTexSize.x;
                            float h = uTexSize.y;
                            float ix = mod(id, w);
                            float iy = floor(id / w);
                            vec2 uv = vec2((ix + 0.5) / w, (iy + 0.5) / h);
                            vec4 s = texture2D(uSamples, uv);
                            vec3 pos = s.xyz;
                            float psi = s.w;
                            vPsi = psi;
                            if (psi >= 0.0) vColor = vec3(0.18, 0.39, 0.88); else vColor = vec3(1.0, 0.4, 0.4);
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = uPointSize * (1.0 + clamp(abs(psi) * 8.0, 0.0, 6.0));
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        precision highp float;
                        varying float vPsi;
                        varying vec3 vColor;
                        void main() {
                            float a = clamp(abs(vPsi) * 2.0, 0.0, 1.0);
                            gl_FragColor = vec4(vColor * a, a);
                        }
                    `,
                    transparent: true,
                    depthWrite: !occlusionEnabled,
                    depthTest: occlusionEnabled,
                    blending: THREE.AdditiveBlending
                });

                const points = new THREE.Points(geom, mat);
                points.userData = points.userData || {};
                points.userData.isOrbital = true;
                return points;
            }

            // Regenerate using true probability density |psi|^2 and GPU instancing (InstancedMesh)
            function regenerateOrbitalGeometry() {
                const { n, l, m } = currentOrbitalData;
                const numPoints = parseInt(densitySlider.value);

                // Remove any previous orbital objects from the scene (safe cleanup)
                scene.children.slice().forEach(child => {
                    if (child.userData && child.userData.isOrbital) {
                        // dispose geometries/materials if present
                        if (child.type === 'Group') {
                            child.children.forEach(ch => {
                                ch.geometry?.dispose?.();
                                ch.material?.dispose?.();
                            });
                        } else {
                            child.geometry?.dispose?.();
                            child.material?.dispose?.();
                        }
                        scene.remove(child);
                    }
                });
                currentOrbital = null;

                // Estimate max |psi|^2 for normalization (rejection sampling)
                const maxPsi2 = estimateMaxPsi2(n, l, m);

                // If GPU mode requested but renderer doesn't support float render targets, fallback
                if (renderMode === 'gpu') {
                    const supports = renderer.capabilities.isWebGL2 && (renderer.extensions.get('EXT_color_buffer_float') || renderer.extensions.get('WEBGL_color_buffer_float'));
                    if (!supports) {
                        console.warn('Floating point render targets not supported; falling back to points mode');
                        renderMode = 'points';
                    } else {
                        console.info('GPU sampling enabled (float render targets available)');
                    }
                }

                // Geometry & materials (reuse by caching on function property)
                if (!regenerateOrbitalGeometry._sphereGeo) {
                    regenerateOrbitalGeometry._sphereGeo = new THREE.SphereGeometry(0.12, 6, 6);
                    regenerateOrbitalGeometry._quadGeo = new THREE.PlaneBufferGeometry(0.24, 0.24); // quad for impostors
                    const commonMatOpts = {
                        transparent: true,
                        opacity: 0.5,
                        depthWrite: !occlusionEnabled,
                        depthTest: occlusionEnabled,
                        blending: THREE.AdditiveBlending
                    };
                    regenerateOrbitalGeometry._matPos = new THREE.MeshBasicMaterial({ color: colorPositive, ...commonMatOpts });
                    regenerateOrbitalGeometry._matNeg = new THREE.MeshBasicMaterial({ color: colorNegative, ...commonMatOpts });
                    
                    // Billboard materials for impostors
                    const billboardVertShader = `
                        attribute vec3 instancePosition;
                        attribute float instanceScale;
                        varying vec3 vColor;
                        uniform vec3 color;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform vec3 cameraPosition;
                        
                        void main() {
                            vec3 pos = instancePosition;
                            vec3 toCamera = normalize(cameraPosition - pos);
                            vec3 up = vec3(0.0, 1.0, 0.0);
                            vec3 right = normalize(cross(toCamera, up));
                            up = cross(right, toCamera);
                            
                            vec3 vertex = position * instanceScale;
                            vertex = right * vertex.x + up * vertex.y + toCamera * vertex.z;
                            pos += vertex;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                            vColor = color;
                        }
                    `;
                    const billboardFragShader = `
                        varying vec3 vColor;
                        void main() {
                            gl_FragColor = vec4(vColor, 1.0);
                        }
                    `;
                    
                    regenerateOrbitalGeometry._matPosBillboard = new THREE.ShaderMaterial({
                        uniforms: {
                            color: { value: colorPositive },
                            cameraPosition: { value: camera.position }
                        },
                        vertexShader: billboardVertShader,
                        fragmentShader: billboardFragShader,
                        transparent: true,
                        depthWrite: !occlusionEnabled,
                        depthTest: occlusionEnabled,
                        blending: THREE.AdditiveBlending
                    });
                    
                    regenerateOrbitalGeometry._matNegBillboard = new THREE.ShaderMaterial({
                        uniforms: {
                            color: { value: colorNegative },
                            cameraPosition: { value: camera.position }
                        },
                        vertexShader: billboardVertShader,
                        fragmentShader: billboardFragShader,
                        transparent: true,
                        depthWrite: !occlusionEnabled,
                        depthTest: occlusionEnabled,
                        blending: THREE.AdditiveBlending
                    });
                }
                const sphereGeo = regenerateOrbitalGeometry._sphereGeo;
                const quadGeo = regenerateOrbitalGeometry._quadGeo;
                const matPos = regenerateOrbitalGeometry._matPos;
                const matNeg = regenerateOrbitalGeometry._matNeg;
                const matPosBillboard = regenerateOrbitalGeometry._matPosBillboard;
                const matNegBillboard = regenerateOrbitalGeometry._matNegBillboard;

                // Choose rendering path
                if (renderMode === 'points') {
                    // Remove old (already cleaned above)
                    // Ensure capacity
                    if (!pointsCache.geometry || pointsCache.capacity < numPoints) {
                        pointsCache.geometry?.dispose?.();
                        pointsCache.material?.dispose?.();
                        const geom = new THREE.BufferGeometry();
                        const posArr = new Float32Array(numPoints * 3);
                        const colArr = new Float32Array(numPoints * 3);
                        geom.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
                        geom.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
                        pointsCache.geometry = geom;
                        pointsCache.material = new THREE.PointsMaterial({ size: 0.08, vertexColors: true, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending, depthWrite: !occlusionEnabled, depthTest: occlusionEnabled });
                        pointsCache.capacity = numPoints;
                    }
                    const geom = pointsCache.geometry;
                    const posArr = geom.getAttribute('position').array;
                    const colArr = geom.getAttribute('color').array;
                    // Fill via rejection sampling using estimateMaxPsi2
                    const maxPsi2 = estimateMaxPsi2(n, l, m, Math.min(1200, Math.max(200, numPoints)));
                    let written = 0, attempts = 0, MAX_ATTEMPTS = numPoints * 20;
                    while (written < numPoints && attempts < MAX_ATTEMPTS) {
                        attempts++;
                        const r = Math.random() * maxRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        const cosPhi = Math.cos(phi);
                        const x = r * sinTheta * cosPhi;
                        const y = r * sinTheta * Math.sin(phi);
                        const z = r * cosTheta;
                        const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                        const psi2 = psi * psi;
                        if (Math.random() <= psi2 / maxPsi2) {
                            const i = written * 3;
                            posArr[i] = x; posArr[i+1] = y; posArr[i+2] = z;
                            const c = psi >= 0 ? colorPositive : colorNegative;
                            colArr[i] = c.r; colArr[i+1] = c.g; colArr[i+2] = c.b;
                            written++;
                        }
                    }
                    geom.getAttribute('position').needsUpdate = true;
                    geom.getAttribute('color').needsUpdate = true;
                    const points = new THREE.Points(geom, pointsCache.material);
                    points.userData = points.userData || {};
                    points.userData.isOrbital = true;
                    currentOrbital = points;
                    scene.add(points);
                    // store capacities
                    currentOrbital._posCapacity = Math.ceil(numPoints/2);
                    currentOrbital._negCapacity = Math.floor(numPoints/2);
                    currentOrbital._lastConfig = { n, l, m, numPoints };
                    return;
                }

                // GPU mode: render samples into a float texture then draw points that read from it
                if (renderMode === 'gpu') {
                    // Clean old (already cleaned above)
                    const rt = renderGPUSamples(n, l, m, numPoints);
                    // create GPU points mesh
                    gpuSampleTarget = rt;
                    if (gpuSampleMesh) {
                        gpuSampleMesh.geometry.dispose();
                        gpuSampleMesh.material.dispose();
                        scene.remove(gpuSampleMesh);
                        gpuSampleMesh = null;
                    }
                    gpuSampleMesh = createGPUPointsMesh(rt, numPoints);
                    gpuSampleMesh.userData = gpuSampleMesh.userData || {};
                    gpuSampleMesh.userData.isOrbital = true;
                    currentOrbital = gpuSampleMesh;
                    scene.add(gpuSampleMesh);
                    currentOrbital._lastConfig = { n, l, m, numPoints };
                    return;
                }

                // First pass: sample and store transforms separately by sign
                const posTransforms = [];
                const negTransforms = [];
                const MAX_ATTEMPTS = numPoints * 5;
                let attempts = 0;
                while ((posTransforms.length + negTransforms.length) < numPoints && attempts < MAX_ATTEMPTS) {
                    attempts++;
                    const r = Math.random() * maxRadius;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = Math.random() * 2 * Math.PI;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    const cosPhi = Math.cos(phi);
                    const sinPhi = Math.sin(phi);
                    const x = r * sinTheta * cosPhi;
                    const y = r * sinTheta * sinPhi;
                    const z = r * cosTheta;
                    const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                    const psi2 = psi * psi;
                    if (Math.random() <= psi2 / maxPsi2) {
                        const scale = 0.55 + 0.45 * Math.min(1, Math.sqrt(psi2 / maxPsi2));
                        if (psi >= 0) posTransforms.push({ x, y, z, scale }); else negTransforms.push({ x, y, z, scale });
                    }
                }

                // Choose geometry and materials based on impostor mode (only for instanced mode)
                const useImpostor = impostorEnabled && renderMode === 'instanced';
                const useGeo = useImpostor ? quadGeo : sphereGeo;
                const useMatPos = useImpostor ? matPosBillboard : matPos;
                const useMatNeg = useImpostor ? matNegBillboard : matNeg;

                const posMesh = new THREE.InstancedMesh(useGeo, useMatPos, posTransforms.length || 1);
                const negMesh = new THREE.InstancedMesh(useGeo, useMatNeg, negTransforms.length || 1);
                // mark meshes so global cleanup will remove them when changing modes
                posMesh.userData = posMesh.userData || {};
                negMesh.userData = negMesh.userData || {};
                posMesh.userData.isOrbital = true;
                negMesh.userData.isOrbital = true;

                // For impostors, add instance attributes for position and scale
                if (useImpostor) {
                    const posPositions = new Float32Array(posTransforms.length * 3);
                    const posScales = new Float32Array(posTransforms.length);
                    posTransforms.forEach((t, i) => {
                        posPositions[i*3] = t.x;
                        posPositions[i*3+1] = t.y;
                        posPositions[i*3+2] = t.z;
                        posScales[i] = t.scale;
                    });
                    posMesh.geometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(posPositions, 3));
                    posMesh.geometry.setAttribute('instanceScale', new THREE.InstancedBufferAttribute(posScales, 1));
                    
                    const negPositions = new Float32Array(negTransforms.length * 3);
                    const negScales = new Float32Array(negTransforms.length);
                    negTransforms.forEach((t, i) => {
                        negPositions[i*3] = t.x;
                        negPositions[i*3+1] = t.y;
                        negPositions[i*3+2] = t.z;
                        negScales[i] = t.scale;
                    });
                    negMesh.geometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(negPositions, 3));
                    negMesh.geometry.setAttribute('instanceScale', new THREE.InstancedBufferAttribute(negScales, 1));
                } else {
                    // For spheres, use the standard instance matrix approach
                    posTransforms.forEach((t, i) => {
                        dummyObject3D.position.set(t.x, t.y, t.z);
                        dummyObject3D.scale.setScalar(t.scale);
                        dummyObject3D.updateMatrix();
                        posMesh.setMatrixAt(i, dummyObject3D.matrix);
                    });
                    negTransforms.forEach((t, i) => {
                        dummyObject3D.position.set(t.x, t.y, t.z);
                        dummyObject3D.scale.setScalar(t.scale);
                        dummyObject3D.updateMatrix();
                        negMesh.setMatrixAt(i, dummyObject3D.matrix);
                    });
                }
                posMesh.instanceMatrix.needsUpdate = true;
                negMesh.instanceMatrix.needsUpdate = true;

                const group = new THREE.Group();
                group.add(posMesh);
                group.add(negMesh);
                // mark group for cleanup as well
                group.userData = group.userData || {};
                group.userData.isOrbital = true;
                currentOrbital = group;
                scene.add(group);
                // Store capacity metadata for in-place updates
                currentOrbital._posCapacity = posMesh.count;
                currentOrbital._negCapacity = negMesh.count;
                currentOrbital._lastConfig = { n, l, m, numPoints };
            }

            function scheduleRegeneration(delay = 60) {
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(regenerateOrbitalGeometry, delay);
            }

            // In-place resampling without reallocating meshes (called each frame when not paused)
            function resampleOrbitalInPlace() {
                // GPU mode: re-render samples into the target and update points texture
                if (renderMode === 'gpu') {
                    const { n: gpuN, l: gpuL, m: gpuM } = currentOrbitalData;
                    const gpuDesiredPoints = parseInt(densitySlider.value);
                    // If config changed, regenerate geometry
                    const gpuSameConfig = currentOrbital && currentOrbital._lastConfig && currentOrbital._lastConfig.n === gpuN && currentOrbital._lastConfig.l === gpuL && currentOrbital._lastConfig.m === gpuM && currentOrbital._lastConfig.numPoints === gpuDesiredPoints;
                    const rt = renderGPUSamples(gpuN, gpuL, gpuM, gpuDesiredPoints);
                    gpuSampleTarget = rt;

                    // Ensure old orbital objects are removed before adding/updating GPU mesh
                    scene.children.slice().forEach(child => {
                        if (child.userData && child.userData.isOrbital) {
                            if (child !== gpuSampleMesh) {
                                child.geometry?.dispose?.();
                                child.material?.dispose?.();
                                scene.remove(child);
                            }
                        }
                    });

                    if (gpuSampleMesh) {
                        gpuSampleMesh.material.uniforms.uSamples.value = rt.texture;
                        currentOrbital._lastConfig = { n: gpuN, l: gpuL, m: gpuM, numPoints: gpuDesiredPoints };
                    } else {
                        // create mesh if missing
                        gpuSampleMesh = createGPUPointsMesh(rt, gpuDesiredPoints);
                        gpuSampleMesh.userData = gpuSampleMesh.userData || {};
                        gpuSampleMesh.userData.isOrbital = true;
                        scene.add(gpuSampleMesh);
                        currentOrbital = gpuSampleMesh;
                        currentOrbital._lastConfig = { n: gpuN, l: gpuL, m: gpuM, numPoints: gpuDesiredPoints };
                    }
                    return;
                }

                // Points mode: resample the buffer geometry positions and colors
                if (renderMode === 'points') {
                    if (!currentOrbital || currentOrbital.type !== 'Points') return;
                    const { n: pointsN, l: pointsL, m: pointsM } = currentOrbitalData;
                    const pointsDesiredPoints = parseInt(densitySlider.value);
                    const pointsSameConfig = currentOrbital._lastConfig && currentOrbital._lastConfig.n === pointsN && currentOrbital._lastConfig.l === pointsL && currentOrbital._lastConfig.m === pointsM && currentOrbital._lastConfig.numPoints === pointsDesiredPoints;
                    if (!pointsSameConfig) {
                        regenerateOrbitalGeometry();
                        return;
                    }
                    
                    const geom = currentOrbital.geometry;
                    const posArr = geom.getAttribute('position').array;
                    const colArr = geom.getAttribute('color').array;
                    const numPoints = posArr.length / 3;
                    
                    if (!adaptiveEnabled) {
                        // Full refresh for points mode
                        const maxPsi2 = estimateMaxPsi2(pointsN, pointsL, pointsM, Math.min(1200, Math.max(200, numPoints)));
                        let written = 0, attempts = 0, MAX_ATTEMPTS = numPoints * 20;
                        while (written < numPoints && attempts < MAX_ATTEMPTS) {
                            attempts++;
                            const r = Math.random() * maxRadius;
                            const theta = Math.acos(2 * Math.random() - 1);
                            const phi = Math.random() * 2 * Math.PI;
                            const sinTheta = Math.sin(theta);
                            const cosTheta = Math.cos(theta);
                            const cosPhi = Math.cos(phi);
                            const x = r * sinTheta * cosPhi;
                            const y = r * sinTheta * Math.sin(phi);
                            const z = r * cosTheta;
                            const psi = getWaveFunctionValue(pointsN, pointsL, pointsM, r, theta, phi);
                            const psi2 = psi * psi;
                            if (Math.random() <= psi2 / maxPsi2) {
                                const i = written * 3;
                                posArr[i] = x; posArr[i+1] = y; posArr[i+2] = z;
                                const c = psi >= 0 ? colorPositive : colorNegative;
                                colArr[i] = c.r; colArr[i+1] = c.g; colArr[i+2] = c.b;
                                written++;
                            }
                        }
                        // Fill remaining with zeros (invisible points)
                        for (let i = written; i < numPoints; i++) {
                            const idx = i * 3;
                            posArr[idx] = 0; posArr[idx+1] = 0; posArr[idx+2] = 0;
                            colArr[idx] = 0; colArr[idx+1] = 0; colArr[idx+2] = 0;
                        }
                    } else {
                        // Adaptive mode for points: update random subset
                        if (!cachedMaxPsi2 || adaptiveFrame % ADAPTIVE_MAX_RECALC_INTERVAL === 0) {
                            const fresh = estimateMaxPsi2(pointsN, pointsL, pointsM, 600);
                            if (emaMaxPsi2 == null) emaMaxPsi2 = fresh; else emaMaxPsi2 = EMA_ALPHA * fresh + (1 - EMA_ALPHA) * emaMaxPsi2;
                            cachedMaxPsi2 = emaMaxPsi2;
                        }
                        const maxPsi2 = cachedMaxPsi2 || 1e-6;
                        const updates = Math.max(1, Math.floor(numPoints * SUBSET_RESAMPLE_FRACTION));
                        
                        let attempts = 0, accepted = 0;
                        for (let i = 0; i < updates; i++) {
                            const idx = (Math.random() * numPoints) | 0;
                            const ATTEMPT_LIMIT = 40;
                            for (let a = 0; a < ATTEMPT_LIMIT; a++) {
                                attempts++;
                                const r = Math.random() * maxRadius;
                                const theta = Math.acos(2 * Math.random() - 1);
                                const phi = Math.random() * 2 * Math.PI;
                                const sinTheta = Math.sin(theta);
                                const cosTheta = Math.cos(theta);
                                const cosPhi = Math.cos(phi);
                                const sinPhi = Math.sin(phi);
                                const x = r * sinTheta * cosPhi;
                                const y = r * sinTheta * sinPhi;
                                const z = r * cosTheta;
                                const psi = getWaveFunctionValue(pointsN, pointsL, pointsM, r, theta, phi);
                                const psi2 = psi * psi;
                                if (Math.random() <= psi2 / maxPsi2) {
                                    const posIdx = idx * 3;
                                    posArr[posIdx] = x; posArr[posIdx+1] = y; posArr[posIdx+2] = z;
                                    const c = psi >= 0 ? colorPositive : colorNegative;
                                    colArr[posIdx] = c.r; colArr[posIdx+1] = c.g; colArr[posIdx+2] = c.b;
                                    accepted++;
                                    break;
                                }
                            }
                        }
                        currentOrbital._prevAcceptRatio = accepted > 0 ? (accepted / attempts) : currentOrbital._prevAcceptRatio;
                        adaptiveFrame++;
                    }
                    
                    geom.getAttribute('position').needsUpdate = true;
                    geom.getAttribute('color').needsUpdate = true;
                    return;
                }

                if (!currentOrbital || currentOrbital.type !== 'Group') return;
                const { n, l, m } = currentOrbitalData;
                const desiredPoints = parseInt(densitySlider.value);
                const sameConfig = currentOrbital._lastConfig && currentOrbital._lastConfig.n === n && currentOrbital._lastConfig.l === l && currentOrbital._lastConfig.m === m && currentOrbital._lastConfig.numPoints === desiredPoints;
                if (!sameConfig) {
                    regenerateOrbitalGeometry();
                    return;
                }
                const posMesh = currentOrbital.children[0];
                const negMesh = currentOrbital.children[1];
                const posCapacity = currentOrbital._posCapacity;
                const negCapacity = currentOrbital._negCapacity;
                const totalCapacity = posCapacity + negCapacity;
                if (!adaptiveEnabled) {
                    // ORIGINAL full refresh path (non-adaptive)
                    let posFilled = 0, negFilled = 0, attempts = 0, accepted = 0;
                    const maxPsi2 = estimateMaxPsi2(n, l, m, 1500);
                    const maxAttempts = totalCapacity * 15;
                    while ((posFilled < posCapacity || negFilled < negCapacity) && attempts < maxAttempts) {
                        attempts++;
                        const r = Math.random() * maxRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        const cosPhi = Math.cos(phi);
                        const x = r * sinTheta * cosPhi;
                        const y = r * sinTheta * Math.sin(phi);
                        const z = r * cosTheta;
                        const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                        const psi2 = psi * psi;
                        if (Math.random() <= psi2 / maxPsi2) {
                            const scale = 0.55 + 0.45 * Math.min(1, Math.sqrt(psi2 / maxPsi2));
                            dummyObject3D.position.set(x, y, z);
                            dummyObject3D.scale.setScalar(scale);
                            dummyObject3D.updateMatrix();
                            if (psi >= 0 && posFilled < posCapacity) {
                                posMesh.setMatrixAt(posFilled++, dummyObject3D.matrix);
                            } else if (psi < 0 && negFilled < negCapacity) {
                                negMesh.setMatrixAt(negFilled++, dummyObject3D.matrix);
                            }
                            accepted++;
                        }
                    }
                    // Hide remainder
                    if (posFilled < posCapacity) {
                        dummyObject3D.scale.setScalar(0); dummyObject3D.updateMatrix();
                        for (let i = posFilled; i < posCapacity; i++) posMesh.setMatrixAt(i, dummyObject3D.matrix);
                    }
                    if (negFilled < negCapacity) {
                        dummyObject3D.scale.setScalar(0); dummyObject3D.updateMatrix();
                        for (let i = negFilled; i < negCapacity; i++) negMesh.setMatrixAt(i, dummyObject3D.matrix);
                    }
                    posMesh.instanceMatrix.needsUpdate = true;
                    negMesh.instanceMatrix.needsUpdate = true;
                    return;
                }

                // ADAPTIVE MODE: incremental subset update
                if (!cachedMaxPsi2 || adaptiveFrame % ADAPTIVE_MAX_RECALC_INTERVAL === 0) {
                    const fresh = estimateMaxPsi2(n, l, m, 600);
                    if (emaMaxPsi2 == null) emaMaxPsi2 = fresh; else emaMaxPsi2 = EMA_ALPHA * fresh + (1 - EMA_ALPHA) * emaMaxPsi2;
                    cachedMaxPsi2 = emaMaxPsi2;
                }
                const maxPsi2 = cachedMaxPsi2 || 1e-6;
                const posUpdates = Math.max(1, Math.floor(posCapacity * SUBSET_RESAMPLE_FRACTION));
                const negUpdates = Math.max(1, Math.floor(negCapacity * SUBSET_RESAMPLE_FRACTION));

                let attempts = 0, accepted = 0;
                function updateOne(targetMesh, isPositive, index) {
                    // attempt loop per slot
                    const ATTEMPT_LIMIT = 40;
                    for (let a = 0; a < ATTEMPT_LIMIT; a++) {
                        attempts++;
                        const r = Math.random() * maxRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        const sinTheta = Math.sin(theta);
                        const cosTheta = Math.cos(theta);
                        const cosPhi = Math.cos(phi);
                        const sinPhi = Math.sin(phi);
                        const x = r * sinTheta * cosPhi;
                        const y = r * sinTheta * sinPhi;
                        const z = r * cosTheta;
                        const psi = getWaveFunctionValue(n, l, m, r, theta, phi);
                        if ((isPositive && psi < 0) || (!isPositive && psi >= 0)) continue; // sign mismatch
                        const psi2 = psi * psi;
                        if (Math.random() <= psi2 / maxPsi2) {
                            const scale = 0.55 + 0.45 * Math.min(1, Math.sqrt(psi2 / maxPsi2));
                            dummyObject3D.position.set(x, y, z);
                            dummyObject3D.scale.setScalar(scale);
                            dummyObject3D.updateMatrix();
                            targetMesh.setMatrixAt(index, dummyObject3D.matrix);
                            accepted++;
                            break;
                        }
                    }
                }
                for (let i = 0; i < posUpdates; i++) updateOne(posMesh, true, (Math.random() * posCapacity) | 0);
                for (let i = 0; i < negUpdates; i++) updateOne(negMesh, false, (Math.random() * negCapacity) | 0);
                posMesh.instanceMatrix.needsUpdate = true;
                negMesh.instanceMatrix.needsUpdate = true;
                currentOrbital._prevAcceptRatio = accepted > 0 ? (accepted / attempts) : currentOrbital._prevAcceptRatio;
                adaptiveFrame++;
            }

             // --- FPS Counter Logic ---
            let prevTime = performance.now();
            let frames = 0;
            const fpsCounter = document.getElementById('fps-counter');

            // --- Event Listeners and Initial State ---
            const buttons = document.querySelectorAll('#orbital-panel .orbital-button');
            const densitySlider = document.getElementById('density-slider');
            const densityValueLabel = document.getElementById('density-value');
            const pauseButton = document.getElementById('pause-toggle');
            const adaptiveButton = document.getElementById('adaptive-toggle');
            const modeButton = document.getElementById('mode-toggle');
            const impostorButton = document.getElementById('impostor-toggle');
            const cullButton = document.getElementById('cull-toggle');
            const clearButton = document.getElementById('clear-button');

            // Initialize button states
            pauseButton.textContent = paused ? 'Resume' : 'Pause';
            adaptiveButton.textContent = adaptiveEnabled ? 'Adaptive On' : 'Adaptive Off';
            modeButton.textContent = renderMode === 'instanced' ? 'Mode: Instanced' : (renderMode === 'points' ? 'Mode: Points' : 'Mode: GPU');
            impostorButton.textContent = impostorEnabled ? 'Impostor: On' : 'Impostor: Off';
            cullButton.textContent = occlusionEnabled ? 'Cull: On' : 'Cull: Off';

            buttons.forEach(button => {
                button.addEventListener('click', (event) => {
                    buttons.forEach(btn => btn.classList.remove('active'));
                    event.target.classList.add('active');
                    const orbitalType = event.target.dataset.orbital;
                    switch (orbitalType) {
                        case '1s': currentOrbitalData = { n: 1, l: 0, m: 0 }; break;
                        case '2s': currentOrbitalData = { n: 2, l: 0, m: 0 }; break;
                        case '3s': currentOrbitalData = { n: 3, l: 0, m: 0 }; break;
                        case '2p_x': currentOrbitalData = { n: 2, l: 1, m: 1 }; break;
                        case '2p_y': currentOrbitalData = { n: 2, l: 1, m: -1 }; break;
                        case '2p_z': currentOrbitalData = { n: 2, l: 1, m: 0 }; break;
                        case '3p_x': currentOrbitalData = { n: 3, l: 1, m: 1 }; break;
                        case '3p_y': currentOrbitalData = { n: 3, l: 1, m: -1 }; break;
                        case '3p_z': currentOrbitalData = { n: 3, l: 1, m: 0 }; break;
                        case '3d_z2': currentOrbitalData = { n: 3, l: 2, m: 0 }; break;
                        case '3d_x2-y2': currentOrbitalData = { n: 3, l: 2, m: 2 }; break;
                        case '3d_xy': currentOrbitalData = { n: 3, l: 2, m: -2 }; break;
                        case '3d_xz': currentOrbitalData = { n: 3, l: 2, m: 1 }; break;
                        case '3d_yz': currentOrbitalData = { n: 3, l: 2, m: -1 }; break;
                        case '4s': currentOrbitalData = { n: 4, l: 0, m: 0 }; break;
                        case '4p_x': currentOrbitalData = { n: 4, l: 1, m: 1 }; break;
                        case '4p_y': currentOrbitalData = { n: 4, l: 1, m: -1 }; break;
                        case '4p_z': currentOrbitalData = { n: 4, l: 1, m: 0 }; break;
                        case '4d_z2': currentOrbitalData = { n: 4, l: 2, m: 0 }; break;
                        case '4d_x2-y2': currentOrbitalData = { n: 4, l: 2, m: 2 }; break;
                        case '4d_xy': currentOrbitalData = { n: 4, l: 2, m: -2 }; break;
                        case '4d_xz': currentOrbitalData = { n: 4, l: 2, m: 1 }; break;
                        case '4d_yz': currentOrbitalData = { n: 4, l: 2, m: -1 }; break;
                    }
                    scheduleRegeneration(80);
                });
            });

            densitySlider.addEventListener('input', (event) => {
                const newDensity = parseInt(event.target.value);
                densityValueLabel.textContent = newDensity.toLocaleString();
                scheduleRegeneration(120);
            });

            pauseButton.addEventListener('click', () => {
                paused = !paused;
                pauseButton.textContent = paused ? 'Resume' : 'Pause';
            });
            adaptiveButton.addEventListener('click', () => {
                adaptiveEnabled = !adaptiveEnabled;
                adaptiveButton.textContent = adaptiveEnabled ? 'Adaptive On' : 'Adaptive Off';
                // Force regeneration to reset caches
                cachedMaxPsi2 = null;
                scheduleRegeneration(10);
            });
            modeButton.addEventListener('click', () => {
                // Cycle through instanced -> points -> gpu
                if (renderMode === 'instanced') renderMode = 'points';
                else if (renderMode === 'points') renderMode = 'gpu';
                else renderMode = 'instanced';
                modeButton.textContent = renderMode === 'instanced' ? 'Mode: Instanced' : (renderMode === 'points' ? 'Mode: Points' : 'Mode: GPU');
                
                // Update impostor button availability
                if (renderMode === 'instanced') {
                    impostorButton.disabled = false;
                    impostorButton.textContent = impostorEnabled ? 'Impostor: On' : 'Impostor: Off';
                } else {
                    impostorButton.disabled = true;
                    impostorButton.textContent = 'Impostor: N/A';
                }
                
                scheduleRegeneration(30);
            });

            // Cull toggle
            cullButton.addEventListener('click', () => {
                occlusionEnabled = !occlusionEnabled;
                cullButton.textContent = occlusionEnabled ? 'Cull: On' : 'Cull: Off';
                // Force regeneration so materials respect depthTest/depthWrite
                scheduleRegeneration(20);
            });

            // Impostor toggle
            impostorButton.addEventListener('click', () => {
                impostorEnabled = !impostorEnabled;
                impostorButton.textContent = impostorEnabled ? 'Impostor: On' : 'Impostor: Off';
                // Force regeneration to switch between spheres and quads
                scheduleRegeneration(20);
            });

            // Clear button
            clearButton.addEventListener('click', () => {
                clearOrbital();
            });

            // Set initial state
            document.querySelector('[data-orbital="1s"]').classList.add('active');
            
            // Handle window resizing (debounced)
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                }, 120);
            });

            // --- Animation Loop ---
            // Render loop (geometry only regenerated on demand)
            const animate = () => {
                requestAnimationFrame(animate);
                if (!paused) {
                    resampleOrbitalInPlace();
                }
                controls.update();
                
                // Update billboard material camera positions for proper billboarding
                if (regenerateOrbitalGeometry._matPosBillboard) {
                    regenerateOrbitalGeometry._matPosBillboard.uniforms.cameraPosition.value.copy(camera.position);
                }
                if (regenerateOrbitalGeometry._matNegBillboard) {
                    regenerateOrbitalGeometry._matNegBillboard.uniforms.cameraPosition.value.copy(camera.position);
                }
                
                renderer.render(scene, camera);
                const currentTime = performance.now();
                frames++;
                if (currentTime - prevTime >= 1000) {
                    fpsCounter.textContent = `FPS: ${frames}`;
                    prevTime = currentTime;
                    frames = 0;
                }
            };

            // Initial generation
            regenerateOrbitalGeometry();
            animate();
        };

        // Remove and dispose any current orbital objects and GPU targets
        function clearOrbital() {
            // remove orbital-marked children
            scene.children.slice().forEach(child => {
                if (child.userData && child.userData.isOrbital) {
                    if (child.type === 'Group') {
                        child.children.forEach(ch => { ch.geometry?.dispose?.(); ch.material?.dispose?.(); });
                    } else {
                        child.geometry?.dispose?.();
                        child.material?.dispose?.();
                    }
                    scene.remove(child);
                }
            });
            // dispose GPU resources
            if (gpuSampleMesh) {
                gpuSampleMesh.geometry?.dispose?.();
                gpuSampleMesh.material?.dispose?.();
                scene.remove(gpuSampleMesh);
                gpuSampleMesh = null;
            }
            if (gpuSampleTarget) {
                gpuSampleTarget.dispose?.();
                gpuSampleTarget = null;
            }
            // clear cached current orbital reference
            currentOrbital = null;
        }
    </script>
</body>
</html>